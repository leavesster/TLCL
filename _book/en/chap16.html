
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>16. 存储媒介 · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="chap17.html" />
    
    
    <link rel="prev" href="chap15.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="chap01.html">
            
                <a href="chap01.html">
            
                    
                    01. 引言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="chap02.html">
            
                <a href="chap02.html">
            
                    
                    02. 什么是 shell
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="chap03.html">
            
                <a href="chap03.html">
            
                    
                    03. 文件系统中跳转
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="chap04.html">
            
                <a href="chap04.html">
            
                    
                    04. 探究操作系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="chap05.html">
            
                <a href="chap05.html">
            
                    
                    05. 操作文件和目录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="chap06.html">
            
                <a href="chap06.html">
            
                    
                    06. 使用命令
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="chap07.html">
            
                <a href="chap07.html">
            
                    
                    07. 重定向
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="chap08.html">
            
                <a href="chap08.html">
            
                    
                    08. 从 shell 眼中看世界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="chap09.html">
            
                <a href="chap09.html">
            
                    
                    09. 键盘高级操作技巧
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="chap10.html">
            
                <a href="chap10.html">
            
                    
                    10. 权限
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="chap11.html">
            
                <a href="chap11.html">
            
                    
                    11. 进程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="chap12.html">
            
                <a href="chap12.html">
            
                    
                    12. shell 环境
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="chap13.html">
            
                <a href="chap13.html">
            
                    
                    13. vi 简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="chap14.html">
            
                <a href="chap14.html">
            
                    
                    14. 自定制 shell 提示符
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.15" data-path="chap15.html">
            
                <a href="chap15.html">
            
                    
                    15. 软件包管理
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.16" data-path="chap16.html">
            
                <a href="chap16.html">
            
                    
                    16. 存储媒介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.17" data-path="chap17.html">
            
                <a href="chap17.html">
            
                    
                    17. 网络系统
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.18" data-path="chap18.html">
            
                <a href="chap18.html">
            
                    
                    18. 查找文件
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.19" data-path="chap19.html">
            
                <a href="chap19.html">
            
                    
                    19. 归档和备份
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.20" data-path="chap20.html">
            
                <a href="chap20.html">
            
                    
                    20. 正则表达式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.21" data-path="chap21.html">
            
                <a href="chap21.html">
            
                    
                    21. 文本处理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.22" data-path="chap22.html">
            
                <a href="chap22.html">
            
                    
                    22. 格式化输出
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.23" data-path="chap23.html">
            
                <a href="chap23.html">
            
                    
                    23. 打印
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.24" data-path="chap24.html">
            
                <a href="chap24.html">
            
                    
                    24. 编译程序
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.25" data-path="chap25.html">
            
                <a href="chap25.html">
            
                    
                    25. 编写第一个 Shell 脚本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.26" data-path="chap26.html">
            
                <a href="chap26.html">
            
                    
                    26. 启动一个项目
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.27" data-path="chap27.html">
            
                <a href="chap27.html">
            
                    
                    27. 自顶向下设计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.28" data-path="chap28.html">
            
                <a href="chap28.html">
            
                    
                    28. 流程控制：if 分支结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.29" data-path="chap29.html">
            
                <a href="chap29.html">
            
                    
                    29. 读取键盘输入
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.30" data-path="chap30.html">
            
                <a href="chap30.html">
            
                    
                    30. 流程控制：while/until 循环
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.31" data-path="chap31.html">
            
                <a href="chap31.html">
            
                    
                    31. 疑难排解
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.32" data-path="chap32.html">
            
                <a href="chap32.html">
            
                    
                    32. 流程控制：case 分支
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.33" data-path="chap33.html">
            
                <a href="chap33.html">
            
                    
                    33. 位置参数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.34" data-path="chap34.html">
            
                <a href="chap34.html">
            
                    
                    34. 流程控制：for 循环
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.35" data-path="chap35.html">
            
                <a href="chap35.html">
            
                    
                    35. 字符串和数字
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.36" data-path="chap36.html">
            
                <a href="chap36.html">
            
                    
                    36. 数组
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.37" data-path="chap37.html">
            
                <a href="chap37.html">
            
                    
                    37. 奇珍异宝
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >16. 存储媒介</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>In previous chapters we&#x2019;ve looked at manipulating data at the file level. In this chapter,
we will consider data at the device level. Linux has amazing capabilities for handling
storage devices, whether physical storage, such as hard disks, or network storage, or
virtual storage devices like RAID (Redundant Array of Independent Disks) and LVM
(Logical Volume Manager).</p>
<p>&#x5728;&#x524D;&#x9762;&#x7AE0;&#x8282;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5DF2;&#x7ECF;&#x4ECE;&#x6587;&#x4EF6;&#x7EA7;&#x522B;&#x770B;&#x4E86;&#x64CD;&#x4F5C;&#x6570;&#x636E;&#x3002;&#x5728;&#x8FD9;&#x7AE0;&#x91CC;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x4ECE;&#x8BBE;&#x5907;&#x7EA7;&#x522B;&#x6765;&#x8003;&#x8651;&#x6570;&#x636E;&#x3002;
Linux &#x6709;&#x7740;&#x4EE4;&#x4EBA;&#x60CA;&#x5947;&#x7684;&#x80FD;&#x529B;&#x6765;&#x5904;&#x7406;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#xFF0C;&#x4E0D;&#x7BA1;&#x662F;&#x7269;&#x7406;&#x8BBE;&#x5907;&#xFF0C;&#x6BD4;&#x5982;&#x8BF4;&#x786C;&#x76D8;&#xFF0C;&#x8FD8;&#x662F;&#x7F51;&#x7EDC;&#x8BBE;&#x5907;&#xFF0C;&#x6216;&#x8005;&#x662F;
&#x865A;&#x62DF;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#xFF0C;&#x50CF; RAID&#xFF08;&#x72EC;&#x7ACB;&#x78C1;&#x76D8;&#x5197;&#x4F59;&#x9635;&#x5217;)&#x548C; LVM&#xFF08;&#x903B;&#x8F91;&#x5377;&#x7BA1;&#x7406;&#x5668;&#xFF09;&#x3002;</p>
<p>However, since this is not a book about system administration, we will not try to cover
this entire topic in depth. What we will try to do is introduce some of the concepts and
key commands that are used to manage storage devices.</p>
<p>&#x7136;&#x800C;&#xFF0C;&#x8FD9;&#x4E0D;&#x662F;&#x4E00;&#x672C;&#x5173;&#x4E8E;&#x7CFB;&#x7EDF;&#x7BA1;&#x7406;&#x7684;&#x4E66;&#x7C4D;&#xFF0C;&#x6211;&#x4EEC;&#x4E0D;&#x4F1A;&#x8BD5;&#x56FE;&#x6DF1;&#x5165;&#x5730;&#x8986;&#x76D6;&#x6574;&#x4E2A;&#x4E3B;&#x9898;&#x3002;&#x6211;&#x4EEC;&#x5C06;&#x52AA;&#x529B;&#x505A;&#x7684;&#x5C31;&#x662F;
&#x4ECB;&#x7ECD;&#x4E00;&#x4E9B;&#x6982;&#x5FF5;&#x548C;&#x7528;&#x6765;&#x7BA1;&#x7406;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x7684;&#x91CD;&#x8981;&#x547D;&#x4EE4;&#x3002;</p>
<p>To carry out the exercises in this chapter, we will use a USB flash drive, a CD-RW disk
(for systems equipped with a CD-ROM burner) and a floppy disk (again, if the system is
so equipped.)</p>
<p>&#x4E3A;&#x4E86;&#x505A;&#x8FD9;&#x4E00;&#x7AE0;&#x7684;&#x7EC3;&#x4E60;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x4F1A;&#x4F7F;&#x7528; USB &#x95EA;&#x5B58;&#xFF0C;CD-RW &#x5149;&#x76D8;&#xFF08;&#x56E0;&#x4E3A;&#x7CFB;&#x7EDF;&#x914D;&#x5907;&#x4E86; CD-ROM &#x70E7;&#x5F55;&#x5668;&#xFF09;
&#x548C;&#x4E00;&#x5F20;&#x8F6F;&#x76D8;&#xFF08;&#x82E5;&#x7CFB;&#x7EDF;&#x8FD9;&#x6837;&#x914D;&#x5907;&#xFF09;&#x3002;</p>
<p>We will look at the following commands:</p>
<p>&#x6211;&#x4EEC;&#x5C06;&#x770B;&#x770B;&#x4EE5;&#x4E0B;&#x547D;&#x4EE4;&#xFF1A;</p>
<ul>
<li><p>mount &#x2013; Mount a file system</p>
</li>
<li><p>mount &#x2013; &#x6302;&#x8F7D;&#x4E00;&#x4E2A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;</p>
</li>
<li><p>umount &#x2013; Unmount a file system</p>
</li>
<li><p>umount &#x2013; &#x5378;&#x8F7D;&#x4E00;&#x4E2A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;</p>
</li>
<li><p>fsck &#x2013; Check and repair a file system</p>
</li>
<li><p>fsck &#x2013; &#x68C0;&#x67E5;&#x548C;&#x4FEE;&#x590D;&#x4E00;&#x4E2A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;</p>
</li>
<li><p>fdisk &#x2013; Partition table manipulator</p>
</li>
<li><p>fdisk &#x2013; &#x5206;&#x533A;&#x8868;&#x63A7;&#x5236;&#x5668;</p>
</li>
<li><p>mkfs &#x2013; Create a file system</p>
</li>
<li><p>mkfs &#x2013; &#x521B;&#x5EFA;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;</p>
</li>
<li><p>fdformat &#x2013; Format a floppy disk</p>
</li>
<li><p>fdformat &#x2013; &#x683C;&#x5F0F;&#x5316;&#x4E00;&#x5F20;&#x8F6F;&#x76D8;</p>
</li>
<li><p>dd &#x2013; Write block oriented data directly to a device</p>
</li>
<li><p>dd &#x2014; &#x628A;&#x9762;&#x5411;&#x5757;&#x7684;&#x6570;&#x636E;&#x76F4;&#x63A5;&#x5199;&#x5165;&#x8BBE;&#x5907;</p>
</li>
<li><p>genisoimage (mkisofs) &#x2013; Create an ISO 9660 image file</p>
</li>
<li><p>genisoimage (mkisofs) &#x2013; &#x521B;&#x5EFA;&#x4E00;&#x4E2A; ISO 9660&#x7684;&#x6620;&#x50CF;&#x6587;&#x4EF6;</p>
</li>
<li><p>wodim (cdrecord) &#x2013; Write data to optical storage media</p>
</li>
<li><p>wodim (cdrecord) &#x2013; &#x628A;&#x6570;&#x636E;&#x5199;&#x5165;&#x5149;&#x5B58;&#x50A8;&#x5A92;&#x4ECB;</p>
</li>
<li><p>md5sum &#x2013; Calculate an MD5 checksum</p>
</li>
<li><p>md5sum &#x2013; &#x8BA1;&#x7B97; MD5&#x68C0;&#x9A8C;&#x7801;</p>
</li>
</ul>
<h3 id="&#x6302;&#x8F7D;&#x548C;&#x5378;&#x8F7D;&#x5B58;&#x50A8;&#x8BBE;&#x5907;">&#x6302;&#x8F7D;&#x548C;&#x5378;&#x8F7D;&#x5B58;&#x50A8;&#x8BBE;&#x5907;</h3>
<p>Recent advances in the Linux desktop have made storage device management extremely
easy for desktop users. For the most part, we attach a device to our system and it &#x201C;just
works.&#x201D; Back in the old days (say, 2004), this stuff had to be done manually. On non-
desktop systems (i.e., servers) this is still a largely manual procedure since servers often
have extreme storage needs and complex configuration requirements.</p>
<p>Linux &#x684C;&#x9762;&#x7CFB;&#x7EDF;&#x7684;&#x6700;&#x65B0;&#x8FDB;&#x5C55;&#x5DF2;&#x7ECF;&#x4F7F;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x7BA1;&#x7406;&#x5BF9;&#x4E8E;&#x684C;&#x9762;&#x7528;&#x6237;&#x6765;&#x8BF4;&#x6781;&#x5176;&#x5BB9;&#x6613;&#x3002;&#x5927;&#x591A;&#x6570;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x6211;&#x4EEC;
&#x53EA;&#x8981;&#x628A;&#x8BBE;&#x5907;&#x8FDE;&#x63A5;&#x5230;&#x7CFB;&#x7EDF;&#x4E2D;&#xFF0C;&#x5B83;&#x5C31;&#x80FD;&#x5DE5;&#x4F5C;&#x3002;&#x5728;&#x8FC7;&#x53BB;&#xFF08;&#x6BD4;&#x5982;&#x8BF4;&#xFF0C;2004&#x5E74;&#xFF09;&#xFF0C;&#x8FD9;&#x4E2A;&#x5DE5;&#x4F5C;&#x5FC5;&#x987B;&#x624B;&#x52A8;&#x5B8C;&#x6210;&#x3002;
&#x5728;&#x975E;&#x684C;&#x9762;&#x7CFB;&#x7EDF;&#x4E2D;&#xFF08;&#x4F8B;&#x5982;&#xFF0C;&#x670D;&#x52A1;&#x5668;&#x4E2D;&#xFF09;&#xFF0C;&#x8FD9;&#x4ECD;&#x7136;&#x662F;&#x4E00;&#x4E2A;&#x4E3B;&#x8981;&#x5730;&#x624B;&#x52A8;&#x8FC7;&#x7A0B;&#xFF0C;&#x56E0;&#x4E3A;&#x670D;&#x52A1;&#x5668;&#x7ECF;&#x5E38;&#x6709;&#x6781;&#x7AEF;&#x7684;&#x5B58;&#x50A8;&#x9700;&#x6C42;
&#x548C;&#x590D;&#x6742;&#x7684;&#x914D;&#x7F6E;&#x8981;&#x6C42;&#x3002;</p>
<p>The first step in managing a storage device is attaching the device to the file system tree.
This process, called mounting, allows the device to participate with the operating system.
As we recall from Chapter 3, Unix-like operating systems, like Linux, maintain a single
file system tree with devices attached at various points. This contrasts with other
operating systems such as MS-DOS and Windows that maintain separate trees for each
device (for example C:\, D:\, etc.).</p>
<p>&#x7BA1;&#x7406;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x7684;&#x7B2C;&#x4E00;&#x6B65;&#x662F;&#x628A;&#x8BBE;&#x5907;&#x8FDE;&#x63A5;&#x5230;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6811;&#x4E2D;&#x3002;&#x8FD9;&#x4E2A;&#x53EB;&#x505A;&#x6302;&#x8F7D;&#x7684;&#x8FC7;&#x7A0B;&#x5141;&#x8BB8;&#x8BBE;&#x5907;&#x53C2;&#x4E0E;&#x5230;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x4E2D;&#x3002;
&#x56DE;&#x60F3;&#x4E00;&#x4E0B;&#x7B2C;&#x4E09;&#x7AE0;&#xFF0C;&#x7C7B; Unix &#x7684;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#xFF0C;&#x50CF; Linux&#xFF0C;&#x5C06;&#x8FDE;&#x63A5;&#x5728;&#x5404;&#x79CD;&#x7ED3;&#x70B9;&#x4E0A;&#x7684;&#x8BBE;&#x5907;&#x5728;&#x4E00;&#x4E2A;&#x5355;&#x4E00;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6811;&#x4E2D;&#x7EF4;&#x62A4;&#x3002;
&#x8FD9;&#x4E0E;&#x5176;&#x5B83;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x5F62;&#x6210;&#x5BF9;&#x7167;&#xFF0C;&#x6BD4;&#x5982;&#x8BF4; MS-DOS &#x548C; Windows &#x7CFB;&#x7EDF;&#x4E2D;&#xFF0C;&#x6BCF;&#x4E2A;&#x8BBE;&#x5907;&#xFF08;&#x4F8B;&#x5982; C:\&#xFF0C;D:\&#xFF0C;&#x7B49;&#xFF09;
&#x4FDD;&#x6301;&#x7740;&#x5355;&#x72EC;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6811;&#x3002;</p>
<p>There is a file named /etc/fstab that lists the devices (typically hard disk partitions)
that are to be mounted at boot time. Here is an example /etc/fstab file from a
Fedora 7 system:</p>
<p>&#x6709;&#x4E00;&#x4E2A;&#x53EB;&#x505A;/etc/fstab &#x7684;&#x6587;&#x4EF6;&#x53EF;&#x4EE5;&#x5217;&#x51FA;&#x7CFB;&#x7EDF;&#x542F;&#x52A8;&#x65F6;&#x8981;&#x6302;&#x8F7D;&#x7684;&#x8BBE;&#x5907;&#xFF08;&#x5178;&#x578B;&#x5730;&#xFF0C;&#x786C;&#x76D8;&#x5206;&#x533A;&#xFF09;&#x3002;&#x4E0B;&#x9762;&#x662F;
&#x6765;&#x81EA;&#x4E8E; Fedora 7&#x7CFB;&#x7EDF;&#x7684;/etc/fstab &#x6587;&#x4EF6;&#x5B9E;&#x4F8B;&#xFF1A;</p>
<pre><code>LABEL=/12               /               ext3        defaults        1   1
LABEL=/home             /home           ext3        defaults        1   2
LABEL=/boot             /boot           ext3        defaults        1   2
tmpfs                   /dev/shm        tmpfs       defaults        0   0
devpts                  /dev/pts        devpts      gid=5,mode=620  0   0
sysfs                   /sys            sysfs       defaults        0   0
proc                    /proc           proc        defaults        0   0
LABEL=SWAP-sda3         /swap           swap        defaults        0   0
</code></pre><p>Most of the file systems listed in this example file are virtual and are not applicable to our
discussion. For our purposes, the interesting ones are the first three:</p>
<p>&#x5728;&#x8FD9;&#x4E2A;&#x5B9E;&#x4F8B;&#x4E2D;&#x6240;&#x5217;&#x51FA;&#x7684;&#x5927;&#x591A;&#x6570;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x662F;&#x865A;&#x62DF;&#x7684;&#xFF0C;&#x5E76;&#x4E0D;&#x9002;&#x7528;&#x4E8E;&#x6211;&#x4EEC;&#x7684;&#x8BA8;&#x8BBA;&#x3002;&#x5C31;&#x6211;&#x4EEC;&#x7684;&#x76EE;&#x7684;&#x800C;&#x8A00;&#xFF0C;
&#x524D;&#x4E09;&#x4E2A;&#x662F;&#x6211;&#x4EEC;&#x611F;&#x5174;&#x8DA3;&#x7684;&#xFF1A;</p>
<pre><code>LABEL=/12               /               ext3        defaults        1   1
LABEL=/home             /home           ext3        defaults        1   2
LABEL=/boot             /boot           ext3        defaults        1   2
</code></pre><p>These are the hard disk partitions. Each line of the file consists of six fields, as follows:</p>
<p>&#x8FD9;&#x4E9B;&#x662F;&#x786C;&#x76D8;&#x5206;&#x533A;&#x3002;&#x6BCF;&#x884C;&#x7531;&#x516D;&#x4E2A;&#x5B57;&#x6BB5;&#x7EC4;&#x6210;&#xFF0C;&#x5982;&#x4E0B;&#x6240;&#x793A;&#xFF1A;</p>
<table class="multi">
<caption class="cap">Table 16-1: /etc/fstab Fields</caption>
<tr>
<th class="title">Field</th>
<th class="title">Contents</th>
<th class="title">Description</th>
</tr>
<tr>
<td valign="top" width="8%">1</td>
<td valign="top" width="12%">Device</td>
<td valign="top">Traditionally, this field contains the actual name of a
device file associated with the physical device, such as
/dev/hda1 (the first partition of the master device
on the first IDE channel). But with today&apos;s computers,
which have many devices that are hot pluggable (like
USB drives), many modern Linux distributions
associate a device with a text label instead. This label
(which is added to the storage media when it is
formatted) is read by the operating system when the
device is attached to the system. That way, no matter
which device file is assigned to the actual physical
device, it can still be correctly identified.
</td>
</tr>
<tr>
<td valign="top">2</td>
<td valign="top">Mount Point</td>
<td valign="top">The directory where the device is attached to the file
system tree.
</td>
</tr>
<tr>
<td valign="top">3</td>
<td valign="top">File System Type</td>
<td valign="top">Linux allows many file system types to be mounted.
Most native Linux file systems are ext3, but many
others are supported, such as FAT16 (msdos), FAT32
(vfat), NTFS (ntfs), CD-ROM (iso9660), etc.
</td>
</tr>
<tr>
<td valign="top">4</td>
<td valign="top">Options</td>
<td valign="top">File systems can be mounted with various options. It
is possible, for example, to mount file systems as
read-only, or prevent any programs from being
executed from them (a useful security feature for removable media.)
</td>
</tr>
<tr>
<td valign="top">5</td>
<td valign="top">Frequency</td>
<td valign="top">A single number that specifies if and when a file
system is to be backed up with the dump command.</td>
</tr>
<tr>
<td valign="top">6</td>
<td valign="top">Order</td>
<td valign="top">A single number that specifies in what order file
systems should be checked with the fsck command.</td>
</tr>
</table>

<table class="multi">
<caption class="cap">&#x8868;16-1: /etc/fstab &#x5B57;&#x6BB5;</caption>
<tr>
<th class="title">&#x5B57;&#x6BB5;</th>
<th class="title">&#x5185;&#x5BB9;</th>
<th class="title">&#x8BF4;&#x660E;</th>
</tr>
<tr>
<td valign="top" width="8%">1</td>
<td valign="top" width="12%">&#x8BBE;&#x5907;&#x540D;</td>
<td valign="top">
&#x4F20;&#x7EDF;&#x4E0A;&#xFF0C;&#x8FD9;&#x4E2A;&#x5B57;&#x6BB5;&#x5305;&#x542B;&#x4E0E;&#x7269;&#x7406;&#x8BBE;&#x5907;&#x76F8;&#x5173;&#x8054;&#x7684;&#x8BBE;&#x5907;&#x6587;&#x4EF6;&#x7684;&#x5B9E;&#x9645;&#x540D;&#x5B57;&#xFF0C;&#x6BD4;&#x5982;&#x8BF4;/dev/hda1&#xFF08;&#x7B2C;&#x4E00;&#x4E2A; IDE
&#x901A;&#x9053;&#x4E0A;&#x7B2C;&#x4E00;&#x4E2A;&#x4E3B;&#x8BBE;&#x5907;&#x5206;&#x533A;&#xFF09;&#x3002;&#x7136;&#x800C;&#x4ECA;&#x5929;&#x7684;&#x8BA1;&#x7B97;&#x673A;&#xFF0C;&#x6709;&#x5F88;&#x591A;&#x70ED;&#x63D2;&#x62D4;&#x8BBE;&#x5907;&#xFF08;&#x50CF; USB &#x9A71;&#x52A8;&#x8BBE;&#x5907;&#xFF09;&#xFF0C;&#x8BB8;&#x591A;
&#x73B0;&#x4EE3;&#x7684; Linux &#x53D1;&#x884C;&#x7248;&#x7528;&#x4E00;&#x4E2A;&#x6587;&#x672C;&#x6807;&#x7B7E;&#x548C;&#x8BBE;&#x5907;&#x76F8;&#x5173;&#x8054;&#x3002;&#x5F53;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x8FDE;&#x63A5;&#x5230;&#x7CFB;&#x7EDF;&#x4E2D;&#x65F6;&#xFF0C;
&#x8FD9;&#x4E2A;&#x6807;&#x7B7E;&#xFF08;&#x5F53;&#x50A8;&#x5B58;&#x5A92;&#x4ECB;&#x683C;&#x5F0F;&#x5316;&#x65F6;&#xFF0C;&#x8FD9;&#x4E2A;&#x6807;&#x7B7E;&#x4F1A;&#x88AB;&#x6DFB;&#x52A0;&#x5230;&#x5B58;&#x50A8;&#x5A92;&#x4ECB;&#x4E2D;&#xFF09;&#x4F1A;&#x88AB;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x8BFB;&#x53D6;&#x3002;
&#x90A3;&#x6837;&#x7684;&#x8BDD;&#xFF0C;&#x4E0D;&#x7BA1;&#x8D4B;&#x7ED9;&#x5B9E;&#x9645;&#x7269;&#x7406;&#x8BBE;&#x5907;&#x54EA;&#x4E2A;&#x8BBE;&#x5907;&#x6587;&#x4EF6;&#xFF0C;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x4ECD;&#x7136;&#x80FD;&#x88AB;&#x7CFB;&#x7EDF;&#x6B63;&#x786E;&#x5730;&#x8BC6;&#x522B;&#x3002;
</td>
</tr>
<tr>
<td valign="top">2</td>
<td valign="top">&#x6302;&#x8F7D;&#x70B9;</td>
<td valign="top">&#x8BBE;&#x5907;&#x6240;&#x8FDE;&#x63A5;&#x5230;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6811;&#x7684;&#x76EE;&#x5F55;&#x3002;
</td>
</tr>
<tr>
<td valign="top">3</td>
<td valign="top">&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;</td>
<td valign="top">Linux &#x5141;&#x8BB8;&#x6302;&#x8F7D;&#x8BB8;&#x591A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#x3002;&#x5927;&#x591A;&#x6570;&#x672C;&#x5730;&#x7684; Linux &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x662F; ext3&#xFF0C;
&#x4F46;&#x662F;&#x4E5F;&#x652F;&#x6301;&#x5F88;&#x591A;&#x5176;&#x5B83;&#x7684;&#xFF0C;&#x6BD4;&#x65B9;&#x8BF4; FAT16 (msdos), FAT32
(vfat)&#xFF0C;NTFS (ntfs)&#xFF0C;CD-ROM (iso9660)&#xFF0C;&#x7B49;&#x7B49;&#x3002;
</td>
</tr>
<tr>
<td valign="top">4</td>
<td valign="top">&#x9009;&#x9879;</td>
<td valign="top">&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5404;&#x79CD;&#x5404;&#x6837;&#x7684;&#x9009;&#x9879;&#x6765;&#x6302;&#x8F7D;&#x3002;&#x6709;&#x53EF;&#x80FD;&#xFF0C;&#x4F8B;&#x5982;&#xFF0C;&#x6302;&#x8F7D;&#x53EA;&#x8BFB;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF0C;
&#x6216;&#x8005;&#x6302;&#x8F7D;&#x963B;&#x6B62;&#x6267;&#x884C;&#x4EFB;&#x4F55;&#x7A0B;&#x5E8F;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF08;&#x4E00;&#x4E2A;&#x6709;&#x7528;&#x7684;&#x5B89;&#x5168;&#x7279;&#x6027;&#xFF0C;&#x907F;&#x514D;&#x5220;&#x9664;&#x5A92;&#x4ECB;&#x3002;&#xFF09;</td>
</tr>
<tr>
<td valign="top">5</td>
<td valign="top">&#x9891;&#x7387;</td>
<td valign="top">&#x4E00;&#x4F4D;&#x6570;&#x5B57;&#xFF0C;&#x6307;&#x5B9A;&#x662F;&#x5426;&#x548C;&#x5728;&#x4EC0;&#x4E48;&#x65F6;&#x95F4;&#x7528; dump &#x547D;&#x4EE4;&#x6765;&#x5907;&#x4EFD;&#x4E00;&#x4E2A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;</td>
</tr>
<tr>
<td valign="top">6</td>
<td valign="top">&#x6B21;&#x5E8F;</td>
<td valign="top">&#x4E00;&#x4F4D;&#x6570;&#x5B57;&#xFF0C;&#x6307;&#x5B9A; fsck &#x547D;&#x4EE4;&#x6309;&#x7167;&#x4EC0;&#x4E48;&#x6B21;&#x5E8F;&#x6765;&#x68C0;&#x67E5;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;</td>
</tr>
</table>

<h3 id="&#x67E5;&#x770B;&#x6302;&#x8F7D;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x5217;&#x8868;">&#x67E5;&#x770B;&#x6302;&#x8F7D;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x5217;&#x8868;</h3>
<p>The mount command is used to mount file systems. Entering the command without
arguments will display a list of the file systems currently mounted:</p>
<p>&#x8FD9;&#x4E2A; mount &#x547D;&#x4EE4;&#x88AB;&#x7528;&#x6765;&#x6302;&#x8F7D;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;&#x6267;&#x884C;&#x8FD9;&#x4E2A;&#x4E0D;&#x5E26;&#x53C2;&#x6570;&#x7684;&#x547D;&#x4EE4;&#xFF0C;&#x5C06;&#x4F1A;&#x663E;&#x793A;
&#x4E00;&#x7CFB;&#x5217;&#x5F53;&#x524D;&#x6302;&#x8F7D;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ mount
/dev/sda2 on / type ext3 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/sda5 on /home type ext3 (rw)
/dev/sda1 on /boot type ext3 (rw)
tmpfs on /dev/shm type tmpfs (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)
fusectl on /sys/fs/fuse/connections type fusectl (rw)
/dev/sdd1 on /media/disk type vfat (rw,nosuid,nodev,noatime,
uhelper=hal,uid=500,utf8,shortname=lower)
twin4:/musicbox on /misc/musicbox type nfs4 (rw,addr=192.168.1.4)
</code></pre><p>The format of the listing is: device on mount_point type file_system_type (options). For
example, the first line shows that device /dev/sda2 is mounted as the root file system
and it is of type ext3 and is both readable and writable (the option &#x201C;rw&#x201D;). This listing also
has two interesting entries at the bottom of the list. The next to last entry shows a 2
gigabyte SD memory card in a card reader mounted at /media/disk, and the last entry
is a network drive mounted at /misc/musicbox.</p>
<p>&#x8FD9;&#x4E2A;&#x5217;&#x8868;&#x7684;&#x683C;&#x5F0F;&#x662F;&#xFF1A;&#x8BBE;&#x5907; on &#x6302;&#x8F7D;&#x70B9; type &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#xFF08;&#x9009;&#x9879;&#xFF09;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x7B2C;&#x4E00;&#x884C;&#x6240;&#x793A;&#x8BBE;&#x5907;/dev/sda2
&#x4F5C;&#x4E3A;&#x6839;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x88AB;&#x6302;&#x8F7D;&#xFF0C;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#x662F; ext3&#xFF0C;&#x5E76;&#x4E14;&#x53EF;&#x8BFB;&#x53EF;&#x5199;&#xFF08;&#x8FD9;&#x4E2A;&#x201C;rw&#x201D;&#x9009;&#x9879;&#xFF09;&#x3002;&#x5728;&#x8FD9;&#x4E2A;&#x5217;&#x8868;&#x7684;&#x5E95;&#x90E8;&#x6709;
&#x4E24;&#x4E2A;&#x6709;&#x8DA3;&#x7684;&#x6761;&#x76EE;&#x3002;&#x5012;&#x6570;&#x7B2C;&#x4E8C;&#x884C;&#x663E;&#x793A;&#x4E86;&#x5728;&#x8BFB;&#x5361;&#x5668;&#x4E2D;&#x7684;&#x4E00;&#x5F20;2G &#x7684; SD &#x5185;&#x5B58;&#x5361;&#xFF0C;&#x6302;&#x8F7D;&#x5230;&#x4E86;/media/disk &#x4E0A;&#x3002;&#x6700;&#x540E;&#x4E00;&#x884C;
&#x662F;&#x4E00;&#x4E2A;&#x7F51;&#x7EDC;&#x8BBE;&#x5907;&#xFF0C;&#x6302;&#x8F7D;&#x5230;&#x4E86;/misc/musicbox &#x4E0A;&#x3002;</p>
<p>For our first experiment, we will work with a CD-ROM. First, let&apos;s look at a system
before a CD-ROM is inserted:</p>
<p>&#x7B2C;&#x4E00;&#x6B21;&#x5B9E;&#x9A8C;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x4F7F;&#x7528;&#x4E00;&#x5F20; CD-ROM&#x3002;&#x9996;&#x5148;&#xFF0C;&#x5728;&#x63D2;&#x5165; CD-ROW &#x4E4B;&#x524D;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x770B;&#x4E00;&#x4E0B;&#x7CFB;&#x7EDF;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ mount
/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/hda1 on /boot type ext3 (rw)
tmpfs on /dev/shm type tmpfs (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)
</code></pre><p>This listing is from a CentOS 5 system, which is using LVM (Logical Volume Manager)
to create its root file system. Like many modern Linux distributions, this system will
attempt to automatically mount the CD-ROM after insertion. After we insert the disk, we
see the following:</p>
<p>&#x8FD9;&#x4E2A;&#x5217;&#x8868;&#x6765;&#x81EA;&#x4E8E; CentOS 5&#x7CFB;&#x7EDF;&#xFF0C;&#x4F7F;&#x7528; LVM&#xFF08;&#x903B;&#x8F91;&#x5377;&#x7BA1;&#x7406;&#x5668;&#xFF09;&#x6765;&#x521B;&#x5EFA;&#x5B83;&#x7684;&#x6839;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;&#x6B63;&#x5982;&#x8BB8;&#x591A;&#x73B0;&#x5728;&#x7684; Linux &#x53D1;&#x884C;&#x7248;&#x4E00;&#x6837;&#xFF0C;&#x8FD9;&#x4E2A;
&#x7CFB;&#x7EDF;&#x8BD5;&#x56FE;&#x81EA;&#x52A8;&#x6302;&#x8F7D;&#x63D2;&#x5165;&#x7684; CD-ROM&#x3002;&#x5F53;&#x6211;&#x4EEC;&#x63D2;&#x5165;&#x5149;&#x76D8;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x770B;&#x770B;&#x4E0B;&#x9762;&#x7684;&#x8F93;&#x51FA;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ mount
/dev/mapper/VolGroup00-LogVol00 on / type ext3 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/hda1 on /boot type ext3 (rw)
tmpfs on /dev/shm type tmpfs (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw)
/dev/hdc on /media/live-1.0.10-8 type iso9660 (ro,noexec,nosuid,
nodev,uid=500)
</code></pre><p>After we insert the disk, we see the same listing as before with one additional entry. At
the end of the listing we see that the CD-ROM (which is device /dev/hdc on this
system) has been mounted on /media/live-1.0.10-8, and is type iso9660 (a CD-
ROM). For purposes of our experiment, we&apos;re interested in the name of the device.
When you conduct this experiment yourself, the device name will most likely be
different.</p>
<p>&#x5F53;&#x6211;&#x4EEC;&#x63D2;&#x5165;&#x5149;&#x76D8;&#x540E;&#xFF0C;&#x9664;&#x4E86;&#x989D;&#x5916;&#x7684;&#x4E00;&#x884C;&#x4E4B;&#x5916;&#xFF0C;&#x6211;&#x4EEC;&#x770B;&#x5230;&#x548C;&#x539F;&#x6765;&#x4E00;&#x6837;&#x7684;&#x5217;&#x8868;&#x3002;&#x5728;&#x5217;&#x8868;&#x7684;&#x672B;&#x5C3E;&#xFF0C;&#x6211;&#x4EEC;
&#x770B;&#x5230; CD-ROW &#x5DF2;&#x7ECF;&#x6302;&#x8F7D;&#x5230;&#x4E86;/media/live-1.0.10-8&#x4E0A;&#xFF0C;&#x5B83;&#x7684;&#x6587;&#x4EF6;&#x7C7B;&#x578B;&#x662F; iso9660&#xFF08;CD-ROW&#xFF09;&#x3002;
&#x5C31;&#x6211;&#x4EEC;&#x7684;&#x5B9E;&#x9A8C;&#x76EE;&#x7684;&#x800C;&#x8A00;&#xFF0C;&#x6211;&#x4EEC;&#x5BF9;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x7684;&#x540D;&#x5B57;&#x611F;&#x5174;&#x8DA3;&#x3002;&#x5F53;&#x4F60;&#x81EA;&#x5DF1;&#x8FDB;&#x884C;&#x8FD9;&#x4E2A;&#x5B9E;&#x9A8C;&#x65F6;&#xFF0C;&#x8FD9;&#x4E2A;
&#x8BBE;&#x5907;&#x540D;&#x5B57;&#x662F;&#x6700;&#x6709;&#x53EF;&#x80FD;&#x4E0D;&#x540C;&#x7684;&#x3002;</p>
<p>Warning: In the examples that follow, it is vitally important that you pay close
attention to the actual device names in use on your system and do not use the
names used in this text!</p>
<p>&#x8B66;&#x544A;&#xFF1A;&#x5728;&#x968F;&#x540E;&#x7684;&#x5B9E;&#x4F8B;&#x4E2D;&#xFF0C;&#x81F3;&#x5173;&#x91CD;&#x8981;&#x7684;&#x662F;&#x4F60;&#x8981;&#x5BC6;&#x5207;&#x6CE8;&#x610F;&#x7528;&#x5728;&#x4F60;&#x7CFB;&#x7EDF;&#x4E2D;&#x7684;&#x5B9E;&#x9645;&#x8BBE;&#x5907;&#x540D;&#xFF0C;&#x5E76;&#x4E14;
&#x4E0D;&#x8981;&#x4F7F;&#x7528;&#x6B64;&#x6587;&#x672C;&#x4E2D;&#x4F7F;&#x7528;&#x7684;&#x540D;&#x5B57;&#xFF01;</p>
<p>Also note that audio CDs are not the same as CD-ROMs. Audio CDs do not
contain file systems and thus cannot be mounted in the usual sense.</p>
<p>&#x8FD8;&#x8981;&#x6CE8;&#x610F;&#x97F3;&#x9891; CD &#x548C; CD-ROW &#x4E0D;&#x4E00;&#x6837;&#x3002;&#x97F3;&#x9891; CD &#x4E0D;&#x5305;&#x542B;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF0C;&#x8FD9;&#x6837;&#x5728;&#x901A;&#x5E38;&#x610F;&#x4E49;&#x4E0A;&#xFF0C;&#x5B83;&#x5C31;&#x4E0D;&#x80FD;&#x88AB;&#x6302;&#x8F7D;&#x4E86;&#x3002;</p>
<p>Now that we have the device name of the CD-ROM drive, let&apos;s unmount the disk and
remount it another location in the file system tree. To do this, we become the superuser
(using the command appropriate for our system) and unmount the disk with the umount
(notice the spelling) command:</p>
<p>&#x73B0;&#x5728;&#x6211;&#x4EEC;&#x62E5;&#x6709; CD-ROW &#x5149;&#x76D8;&#x7684;&#x8BBE;&#x5907;&#x540D;&#x5B57;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x5378;&#x8F7D;&#x8FD9;&#x5F20;&#x5149;&#x76D8;&#xFF0C;&#x5E76;&#x628A;&#x5B83;&#x91CD;&#x65B0;&#x6302;&#x8F7D;&#x5230;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6811;
&#x7684;&#x53E6;&#x4E00;&#x4E2A;&#x4F4D;&#x7F6E;&#x3002;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8D85;&#x7EA7;&#x7528;&#x6237;&#x8EAB;&#x4EFD;&#xFF08;&#x4F7F;&#x7528;&#x7CFB;&#x7EDF;&#x76F8;&#x5E94;&#x7684;&#x547D;&#x4EE4;&#xFF09;&#x6765;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#xFF0C;&#x5E76;&#x4E14;&#x7528;
umount&#xFF08;&#x6CE8;&#x610F;&#x8FD9;&#x4E2A;&#x547D;&#x4EE4;&#x7684;&#x62FC;&#x5199;&#xFF09;&#x6765;&#x5378;&#x8F7D;&#x5149;&#x76D8;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ su -
Password:
[root@linuxbox ~]# umount /dev/hdc
</code></pre><p>The next step is to create a new mount point for the disk. A mount point is simply a
directory somewhere on the file system tree. Nothing special about it. It doesn&apos;t even
have to be an empty directory, though if you mount a device on a non-empty directory,
you will not be able to see the directory&apos;s previous contents until you unmount the device.
For our purposes, we will create a new directory:</p>
<p>&#x4E0B;&#x4E00;&#x6B65;&#x662F;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x5149;&#x76D8;&#x6302;&#x8F7D;&#x70B9;&#x3002;&#x7B80;&#x5355;&#x5730;&#x8BF4;&#xFF0C;&#x4E00;&#x4E2A;&#x6302;&#x8F7D;&#x70B9;&#x5C31;&#x662F;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6811;&#x4E2D;&#x7684;&#x4E00;&#x4E2A;&#x76EE;&#x5F55;&#x3002;&#x5B83;&#x6CA1;&#x6709;
&#x4EC0;&#x4E48;&#x7279;&#x6B8A;&#x7684;&#x3002;&#x5B83;&#x751A;&#x81F3;&#x4E0D;&#x5FC5;&#x662F;&#x4E00;&#x4E2A;&#x7A7A;&#x76EE;&#x5F55;&#xFF0C;&#x5373;&#x4F7F;&#x4F60;&#x628A;&#x8BBE;&#x5907;&#x6302;&#x8F7D;&#x5230;&#x4E86;&#x4E00;&#x4E2A;&#x975E;&#x7A7A;&#x76EE;&#x5F55;&#x4E0A;&#xFF0C;&#x4F60;&#x4E5F;&#x4E0D;&#x80FD;&#x770B;&#x5230;
&#x8FD9;&#x4E2A;&#x76EE;&#x5F55;&#x4E2D;&#x539F;&#x6765;&#x7684;&#x5185;&#x5BB9;&#xFF0C;&#x76F4;&#x5230;&#x4F60;&#x5378;&#x8F7D;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x3002;&#x5C31;&#x6211;&#x4EEC;&#x7684;&#x76EE;&#x7684;&#x800C;&#x8A00;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x76EE;&#x5F55;&#xFF1A;</p>
<pre><code>[root@linuxbox ~]# mkdir /mnt/cdrom
</code></pre><p>Finally, we mount the CD-ROM at the new mount point. The -t option is used to
specify the file system type:</p>
<p>&#x6700;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x628A;&#x8FD9;&#x4E2A; CD-ROW &#x6302;&#x8F7D;&#x5230;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x6302;&#x8F7D;&#x70B9;&#x4E0A;&#x3002;&#x8FD9;&#x4E2A;-t &#x9009;&#x9879;&#x7528;&#x6765;&#x6307;&#x5B9A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#xFF1A;</p>
<pre><code>[root@linuxbox ~]# mount -t iso9660 /dev/hdc /mnt/cdrom
</code></pre><p>Afterward, we can examine the contents of the CD-ROM via the new mount point:</p>
<p>&#x4E4B;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x8FD9;&#x4E2A;&#x65B0;&#x6302;&#x8F7D;&#x70B9;&#x6765;&#x67E5;&#x770B; CD-ROW &#x7684;&#x5185;&#x5BB9;&#xFF1A;</p>
<pre><code>[root@linuxbox ~]# cd /mnt/cdrom
[root@linuxbox cdrom]# ls
</code></pre><p>Notice what happens when we try to unmount the CD-ROM:</p>
<p>&#x6CE8;&#x610F;&#x5F53;&#x6211;&#x4EEC;&#x8BD5;&#x56FE;&#x5378;&#x8F7D;&#x8FD9;&#x4E2A; CD-ROW &#x65F6;&#xFF0C;&#x53D1;&#x751F;&#x4E86;&#x4EC0;&#x4E48;&#x4E8B;&#x60C5;&#x3002;</p>
<pre><code>[root@linuxbox cdrom]# umount /dev/hdc
umount: /mnt/cdrom: device is busy
</code></pre><p>Why is this? The reason is that we cannot unmount a device if the device is being used
by someone or some process. In this case, we changed our working directory to the
mount point for the CD-ROM, which causes the device to be busy. We can easily remedy
the issue by changing the working directory to something other than the mount point:</p>
<p>&#x8FD9;&#x662F;&#x600E;&#x4E48;&#x56DE;&#x4E8B;&#x5462;&#xFF1F;&#x539F;&#x56E0;&#x662F;&#x6211;&#x4EEC;&#x4E0D;&#x80FD;&#x5378;&#x8F7D;&#x4E00;&#x4E2A;&#x8BBE;&#x5907;&#xFF0C;&#x5982;&#x679C;&#x67D0;&#x4E2A;&#x7528;&#x6237;&#x6216;&#x8FDB;&#x7A0B;&#x6B63;&#x5728;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x7684;&#x8BDD;&#x3002;&#x5728;&#x8FD9;&#x79CD;
&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;&#x6211;&#x4EEC;&#x628A;&#x5DE5;&#x4F5C;&#x76EE;&#x5F55;&#x66F4;&#x6539;&#x5230;&#x4E86; CD-ROW &#x7684;&#x6302;&#x8F7D;&#x70B9;&#xFF0C;&#x8FD9;&#x4E2A;&#x6302;&#x8F7D;&#x70B9;&#x5BFC;&#x81F4;&#x8BBE;&#x5907;&#x5FD9;&#x788C;&#x3002;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x5F88;&#x5BB9;&#x6613;&#x5730;&#x4FEE;&#x590D;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;
&#x901A;&#x8FC7;&#x628A;&#x5DE5;&#x4F5C;&#x76EE;&#x5F55;&#x6539;&#x5230;&#x5176;&#x5B83;&#x76EE;&#x5F55;&#x800C;&#x4E0D;&#x662F;&#x8FD9;&#x4E2A;&#x6302;&#x8F7D;&#x70B9;&#x3002;</p>
<pre><code>[root@linuxbox cdrom]# cd
[root@linuxbox ~]# umount /dev/hdc
</code></pre><p>Now the device unmounts successfully.</p>
<p>&#x73B0;&#x5728;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x6210;&#x529F;&#x5378;&#x8F7D;&#x4E86;&#x3002;</p>
<blockquote>
<p>Why Unmounting Is Important</p>
<p>&#x4E3A;&#x4EC0;&#x4E48;&#x5378;&#x8F7D;&#x91CD;&#x8981;</p>
<p>If you look at the output of the free command, which displays statistics about
memory usage, you will see a statistic called &#x201C;buffers.&#x201D; Computer systems are
designed to go as fast as possible. One of the impediments to system speed is
slow devices. Printers are a good example. Even the fastest printer is extremely
slow by computer standards. A computer would be very slow indeed if it had to
stop and wait for a printer to finish printing a page. In the early days of PCs
(before multi-tasking), this was a real problem. If you were working on a
spreadsheet or text document, the computer would stop and become unavailable
every time you printed. The computer would send the data to the printer as fast as
the printer could accept it, but it was very slow since printers don&apos;t print very fast.
This problem was solved by the advent of the printer buffer, a device containing
some RAM memory that would sit between the computer and the printer. With
the printer buffer in place, the computer would send the printer output to the
buffer and it would quickly be stored in the fast RAM so the computer could go
back to work without waiting. Meanwhile, the printer buffer would slowly spool
the data to the printer from the buffer&apos;s memory at the speed at which the printer
could accept it.</p>
<p>&#x5982;&#x679C;&#x4F60;&#x770B;&#x4E00;&#x4E0B; free &#x547D;&#x4EE4;&#x7684;&#x8F93;&#x51FA;&#x7ED3;&#x679C;&#xFF0C;&#x8FD9;&#x4E2A;&#x547D;&#x4EE4;&#x7528;&#x6765;&#x663E;&#x793A;&#x5173;&#x4E8E;&#x5185;&#x5B58;&#x4F7F;&#x7528;&#x60C5;&#x51B5;&#x7684;&#x7EDF;&#x8BA1;&#x4FE1;&#x606F;&#xFF0C;&#x4F60;
&#x4F1A;&#x770B;&#x5230;&#x4E00;&#x4E2A;&#x7EDF;&#x8BA1;&#x503C;&#x53EB;&#x505A;&#x201D;buffers&#x201C;&#x3002;&#x8BA1;&#x7B97;&#x673A;&#x7CFB;&#x7EDF;&#x65E8;&#x5728;&#x5C3D;&#x53EF;&#x80FD;&#x5FEB;&#x5730;&#x8FD0;&#x884C;&#x3002;&#x7CFB;&#x7EDF;&#x8FD0;&#x884C;&#x901F;&#x5EA6;&#x7684;
&#x4E00;&#x4E2A;&#x963B;&#x788D;&#x662F;&#x7F13;&#x6162;&#x7684;&#x8BBE;&#x5907;&#x3002;&#x6253;&#x5370;&#x673A;&#x662F;&#x4E00;&#x4E2A;&#x5F88;&#x597D;&#x7684;&#x4F8B;&#x5B50;&#x3002;&#x5373;&#x4F7F;&#x6700;&#x5FEB;&#x901F;&#x7684;&#x6253;&#x5370;&#x673A;&#x76F8;&#x6BD4;&#x4E8E;&#x8BA1;&#x7B97;&#x673A;&#x6807;&#x51C6;&#x4E5F;
&#x6781;&#x5176;&#x5730;&#x7F13;&#x6162;&#x3002;&#x4E00;&#x53F0;&#x8BA1;&#x7B97;&#x673A;&#x786E;&#x5B9E;&#x4F1A;&#x8FD0;&#x884C;&#x5730;&#x975E;&#x5E38;&#x6162;&#xFF0C;&#x5982;&#x679C;&#x5B83;&#x8981;&#x505C;&#x4E0B;&#x6765;&#x7B49;&#x5F85;&#x4E00;&#x53F0;&#x6253;&#x5370;&#x673A;&#x6253;&#x5370;&#x5B8C;&#x4E00;&#x9875;&#x3002;
&#x5728;&#x65E9;&#x671F;&#x7684;&#x4E2A;&#x4EBA;&#x7535;&#x8111;&#x65F6;&#x4EE3;&#xFF08;&#x591A;&#x4EFB;&#x52A1;&#x4E4B;&#x524D;&#xFF09;&#xFF0C;&#x8FD9;&#x771F;&#x662F;&#x4E2A;&#x95EE;&#x9898;&#x3002;&#x5982;&#x679C;&#x4F60;&#x6B63;&#x5728;&#x7F16;&#x8F91;&#x7535;&#x5B50;&#x8868;&#x683C;
&#x6216;&#x8005;&#x662F;&#x6587;&#x672C;&#x6587;&#x6863;&#xFF0C;&#x6BCF;&#x6B21;&#x4F60;&#x8981;&#x6253;&#x5370;&#x6587;&#x4EF6;&#x65F6;&#xFF0C;&#x8BA1;&#x7B97;&#x673A;&#x90FD;&#x4F1A;&#x505C;&#x4E0B;&#x6765;&#x800C;&#x4E14;&#x53D8;&#x5F97;&#x4E0D;&#x80FD;&#x4F7F;&#x7528;&#x3002;
&#x8BA1;&#x7B97;&#x673A;&#x80FD;&#x4EE5;&#x6253;&#x5370;&#x673A;&#x53EF;&#x63A5;&#x53D7;&#x7684;&#x6700;&#x5FEB;&#x901F;&#x5EA6;&#x628A;&#x6570;&#x636E;&#x53D1;&#x9001;&#x7ED9;&#x6253;&#x5370;&#x673A;&#xFF0C;&#x4F46;&#x7531;&#x4E8E;&#x6253;&#x5370;&#x673A;&#x4E0D;&#x80FD;&#x5FEB;&#x901F;&#x5730;&#x6253;&#x5370;&#xFF0C;
&#x8FD9;&#x4E2A;&#x53D1;&#x9001;&#x901F;&#x5EA6;&#x4F1A;&#x975E;&#x5E38;&#x6162;&#x3002;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;&#x88AB;&#x89E3;&#x51B3;&#x4E86;&#xFF0C;&#x7531;&#x4E8E;&#x6253;&#x5370;&#x673A;&#x7F13;&#x5B58;&#x7684;&#x51FA;&#x73B0;&#xFF0C;&#x4E00;&#x4E2A;&#x5305;&#x542B;&#x4E00;&#x4E9B; RAM &#x5185;&#x5B58;
&#x7684;&#x8BBE;&#x5907;&#xFF0C;&#x4F4D;&#x4E8E;&#x8BA1;&#x7B97;&#x673A;&#x548C;&#x6253;&#x5370;&#x673A;&#x4E4B;&#x95F4;&#x3002;&#x901A;&#x8FC7;&#x6253;&#x5370;&#x673A;&#x7F13;&#x5B58;&#xFF0C;&#x8BA1;&#x7B97;&#x673A;&#x628A;&#x8981;&#x6253;&#x5370;&#x7684;&#x7ED3;&#x679C;&#x53D1;&#x9001;&#x5230;&#x8FD9;&#x4E2A;&#x7F13;&#x5B58;&#x533A;&#xFF0C;
&#x6570;&#x636E;&#x4F1A;&#x8FC5;&#x901F;&#x5730;&#x5B58;&#x50A8;&#x5230;&#x8FD9;&#x4E2A; RAM &#x4E2D;&#xFF0C;&#x8FD9;&#x6837;&#x8BA1;&#x7B97;&#x673A;&#x5C31;&#x80FD;&#x56DE;&#x53BB;&#x5DE5;&#x4F5C;&#xFF0C;&#x800C;&#x4E0D;&#x7528;&#x7B49;&#x5F85;&#x3002;&#x4E0E;&#x6B64;&#x540C;&#x65F6;&#xFF0C;&#x6253;&#x5370;&#x673A;&#x7F13;&#x5B58;&#x5C06;&#x4F1A;
&#x4EE5;&#x6253;&#x5370;&#x673A;&#x53EF;&#x63A5;&#x53D7;&#x7684;&#x901F;&#x5EA6;&#x628A;&#x7F13;&#x5B58;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x7F13;&#x6162;&#x5730;&#x8F93;&#x51FA;&#x7ED9;&#x6253;&#x5370;&#x673A;&#x3002;</p>
<p>This idea of buffering is used extensively in computers to make them faster.
Don&apos;t let the need to occasionally read or write data to/from slow devices impede
the speed of the system. Operating systems store data read from, and to be
written to storage devices in memory for as long as possible before actually
having to interact with the slower device. On a Linux system for example, you
will notice that the system seems to fill up memory the longer it is used. This
does not mean Linux is &#x201C;using&#x201C; all the memory, it means that Linux is taking
advantage of all the available memory to do as much buffering as it can.</p>
<p>&#x7F13;&#x5B58;&#x88AB;&#x5E7F;&#x6CDB;&#x5730;&#x5E94;&#x7528;&#x4E8E;&#x8BA1;&#x7B97;&#x673A;&#x4E2D;&#xFF0C;&#x4F7F;&#x5176;&#x8FD0;&#x884C;&#x5730;&#x66F4;&#x5FEB;&#x3002;&#x522B;&#x8BA9;&#x5076;&#x5C14;&#x5730;&#x8BFB;&#x53D6;&#x6216;&#x5199;&#x5165;&#x6162;&#x8BBE;&#x5907;&#x7684;&#x9700;&#x6C42;&#x963B;&#x788D;&#x4E86;
&#x7CFB;&#x7EDF;&#x7684;&#x8FD0;&#x884C;&#x901F;&#x5EA6;&#x3002;&#x5728;&#x771F;&#x6B63;&#x4E0E;&#x6BD4;&#x8F83;&#x6162;&#x7684;&#x8BBE;&#x5907;&#x4EA4;&#x4E92;&#x4E4B;&#x524D;&#xFF0C;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x4F1A;&#x5C3D;&#x53EF;&#x80FD;&#x591A;&#x7684;&#x8BFB;&#x53D6;&#x6216;&#x5199;&#x5165;&#x6570;&#x636E;&#x5230;&#x5185;&#x5B58;&#x4E2D;&#x7684;
&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x91CC;&#x3002;&#x4EE5; Linux &#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x4E3A;&#x4F8B;&#xFF0C;&#x4F60;&#x4F1A;&#x6CE8;&#x610F;&#x5230;&#x7CFB;&#x7EDF;&#x770B;&#x4F3C;&#x586B;&#x5145;&#x4E86;&#x591A;&#x4E8E;&#x5B83;&#x6240;&#x9700;&#x8981;&#x7684;&#x5185;&#x5B58;&#x3002;
&#x8FD9;&#x4E0D;&#x610F;&#x5473;&#x7740; Linux &#x6B63;&#x5728;&#x4F7F;&#x7528;&#x6240;&#x6709;&#x7684;&#x5185;&#x5B58;&#xFF0C;&#x5B83;&#x610F;&#x5473;&#x7740; Linux &#x6B63;&#x5728;&#x5229;&#x7528;&#x6240;&#x6709;&#x53EF;&#x7528;&#x7684;&#x5185;&#x5B58;&#xFF0C;&#x6765;&#x4F5C;&#x4E3A;&#x7F13;&#x5B58;&#x533A;&#x3002;</p>
<p>This buffering allows writing to storage devices to be done very quickly, because
the writing to the physical device is being deferred to a future time. In the
meantime, the data destined for the device is piling up in memory. From time to
time, the operating system will write this data to the physical device.</p>
<p>&#x8FD9;&#x4E2A;&#x7F13;&#x5B58;&#x533A;&#x5141;&#x8BB8;&#x975E;&#x5E38;&#x5FEB;&#x901F;&#x5730;&#x5199;&#x5165;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#xFF0C;&#x56E0;&#x4E3A;&#x5199;&#x5165;&#x7269;&#x7406;&#x8BBE;&#x5907;&#x7684;&#x64CD;&#x4F5C;&#x88AB;&#x5EF6;&#x8FDF;&#x5230;&#x540E;&#x9762;&#x8FDB;&#x884C;&#x3002;&#x540C;&#x65F6;&#xFF0C;
&#x8FD9;&#x4E9B;&#x6CE8;&#x5B9A;&#x8981;&#x4F20;&#x9001;&#x5230;&#x8BBE;&#x5907;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x6B63;&#x5728;&#x5185;&#x5B58;&#x4E2D;&#x5806;&#x79EF;&#x8D77;&#x6765;&#x3002;&#x65F6;&#x4E0D;&#x65F6;&#x5730;&#xFF0C;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x4F1A;&#x628A;&#x8FD9;&#x4E9B;&#x6570;&#x636E;
&#x5199;&#x5165;&#x7269;&#x7406;&#x8BBE;&#x5907;&#x3002;</p>
<p>Unmounting a device entails writing all the remaining data to the device so that it
can be safely removed. If the device is removed without unmounting it first, the
possibility exists that not all the data destined for the device has been transferred.
In some cases, this data may include vital directory updates, which will lead to
file system corruption, one of the worst things that can happen on a computer.</p>
<p>&#x5378;&#x8F7D;&#x4E00;&#x4E2A;&#x8BBE;&#x5907;&#x9700;&#x8981;&#x628A;&#x6240;&#x6709;&#x5269;&#x4F59;&#x7684;&#x6570;&#x636E;&#x5199;&#x5165;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#xFF0C;&#x6240;&#x4EE5;&#x8BBE;&#x5907;&#x53EF;&#x4EE5;&#x88AB;&#x5B89;&#x5168;&#x5730;&#x79FB;&#x9664;&#x3002;&#x5982;&#x679C;
&#x6CA1;&#x6709;&#x5378;&#x8F7D;&#x8BBE;&#x5907;&#xFF0C;&#x5C31;&#x79FB;&#x9664;&#x4E86;&#x5B83;&#xFF0C;&#x5C31;&#x6709;&#x53EF;&#x80FD;&#x6CA1;&#x6709;&#x628A;&#x6CE8;&#x5B9A;&#x8981;&#x53D1;&#x9001;&#x5230;&#x8BBE;&#x5907;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x8F93;&#x9001;&#x5B8C;&#x6BD5;&#x3002;&#x5728;&#x67D0;&#x4E9B;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;
&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x53EF;&#x80FD;&#x5305;&#x542B;&#x91CD;&#x8981;&#x7684;&#x76EE;&#x5F55;&#x66F4;&#x65B0;&#x4FE1;&#x606F;&#xFF0C;&#x8FD9;&#x5C06;&#x5BFC;&#x81F4;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x635F;&#x574F;&#xFF0C;&#x8FD9;&#x662F;&#x53D1;&#x751F;&#x5728;&#x8BA1;&#x7B97;&#x673A;&#x4E2D;&#x7684;&#x6700;&#x574F;&#x7684;&#x4E8B;&#x60C5;&#x4E4B;&#x4E00;&#x3002;</p>
</blockquote>
<h3 id="&#x786E;&#x5B9A;&#x8BBE;&#x5907;&#x540D;&#x79F0;">&#x786E;&#x5B9A;&#x8BBE;&#x5907;&#x540D;&#x79F0;</h3>
<p>It&apos;s sometimes difficult to determine the name of a device. Back in the old days, it wasn&apos;t
very hard. A device was always in the same place and it didn&apos;t change. Unix-like
systems like it that way. Back when Unix was developed, &#x201C;changing a disk drive&#x201D;
involved using a forklift to remove a washing machine-sized device from the computer
room. In recent years, the typical desktop hardware configuration has become quite
dynamic and Linux has evolved to become more flexible than its ancestors.
In the examples above we took advantage of the modern Linux desktop&apos;s ability to
&#x201C;automagically&#x201D; mount the device and then determine the name after the fact. But what
if we are managing a server or some other environment where this does not occur? How
can we figure it out?</p>
<p>&#x6709;&#x65F6;&#x5F88;&#x96BE;&#x6765;&#x786E;&#x5B9A;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x3002;&#x5728;&#x4EE5;&#x524D;&#xFF0C;&#x8FD9;&#x5E76;&#x4E0D;&#x662F;&#x5F88;&#x96BE;&#x3002;&#x4E00;&#x53F0;&#x8BBE;&#x5907;&#x603B;&#x662F;&#x5728;&#x67D0;&#x4E2A;&#x56FA;&#x5B9A;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x4E5F;&#x4E0D;&#x4F1A;
&#x632A;&#x52A8;&#x5B83;&#x3002;&#x7C7B; Unix &#x7684;&#x7CFB;&#x7EDF;&#x559C;&#x6B22;&#x8BBE;&#x5907;&#x90A3;&#x6837;&#x5B89;&#x6392;&#x3002;&#x4E4B;&#x524D;&#x5728;&#x5F00;&#x53D1; Unix &#x7CFB;&#x7EDF;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x201C;&#x66F4;&#x6539;&#x4E00;&#x4E2A;&#x78C1;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x201D;&#x8981;&#x7528;&#x4E00;&#x8F86;
&#x53C9;&#x8F66;&#x4ECE;&#x673A;&#x623F;&#x4E2D;&#x79FB;&#x9664;&#x4E00;&#x53F0;&#x5982;&#x6D17;&#x8863;&#x673A;&#x5927;&#x5C0F;&#x7684;&#x8BBE;&#x5907;&#x3002;&#x6700;&#x8FD1;&#x51E0;&#x5E74;&#xFF0C;&#x5178;&#x578B;&#x7684;&#x684C;&#x9762;&#x786C;&#x4EF6;&#x914D;&#x7F6E;&#x5DF2;&#x7ECF;&#x53D8;&#x5F97;&#x76F8;&#x5F53;&#x52A8;&#x6001;&#xFF0C;&#x5E76;&#x4E14;
Linux &#x5DF2;&#x7ECF;&#x53D1;&#x5C55;&#x5730;&#x6BD4;&#x5176;&#x7956;&#x5148;&#x66F4;&#x52A0;&#x7075;&#x6D3B;&#x3002;&#x5728;&#x4EE5;&#x4E0A;&#x4E8B;&#x4F8B;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5229;&#x7528;&#x73B0;&#x4EE3; Linux &#x684C;&#x9762;&#x7CFB;&#x7EDF;&#x7684;&#x529F;&#x80FD;&#x6765;&#x201C;&#x81EA;&#x52A8;&#x5730;&#x201D;&#x6302;&#x8F7D;
&#x8BBE;&#x5907;&#xFF0C;&#x7136;&#x540E;&#x518D;&#x786E;&#x5B9A;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x3002;&#x4F46;&#x662F;&#x5982;&#x679C;&#x6211;&#x4EEC;&#x6B63;&#x5728;&#x7BA1;&#x7406;&#x4E00;&#x53F0;&#x670D;&#x52A1;&#x5668;&#x6216;&#x8005;&#x662F;&#x5176;&#x5B83;&#x4E00;&#x4E9B;&#xFF08;&#x8FD9;&#x79CD;&#x81EA;&#x52A8;&#x6302;&#x8F7D;&#x529F;&#x80FD;&#xFF09;&#x4E0D;&#x4F1A;
&#x53D1;&#x751F;&#x7684;&#x73AF;&#x5883;&#xFF0C;&#x6211;&#x4EEC;&#x53C8;&#x5982;&#x4F55;&#x80FD;&#x67E5;&#x6E05;&#x8BBE;&#x5907;&#x540D;&#x5462;&#xFF1F;</p>
<p>First, let&apos;s look at how the system names devices. If we list the contents of the /dev
directory (where all devices live), we can see that there are lots and lots of devices:</p>
<p>&#x9996;&#x5148;&#xFF0C;&#x8BA9;&#x6211;&#x4EEC;&#x770B;&#x4E00;&#x4E0B;&#x7CFB;&#x7EDF;&#x600E;&#x6837;&#x6765;&#x547D;&#x540D;&#x8BBE;&#x5907;&#x3002;&#x5982;&#x679C;&#x6211;&#x4EEC;&#x5217;&#x51FA;&#x76EE;&#x5F55;/dev&#xFF08;&#x6240;&#x6709;&#x8BBE;&#x5907;&#x7684;&#x4F4F;&#x6240;&#xFF09;&#x7684;&#x5185;&#x5BB9;&#xFF0C;&#x6211;&#x4EEC;
&#x4F1A;&#x770B;&#x5230;&#x8BB8;&#x8BB8;&#x591A;&#x591A;&#x7684;&#x8BBE;&#x5907;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ ls /dev
</code></pre><p>The contents of this listing reveal some patterns of device naming. Here are a few:</p>
<p>&#x8FD9;&#x4E2A;&#x5217;&#x8868;&#x7684;&#x5185;&#x5BB9;&#x63ED;&#x793A;&#x4E86;&#x4E00;&#x4E9B;&#x8BBE;&#x5907;&#x547D;&#x540D;&#x7684;&#x6A21;&#x5F0F;&#x3002;&#x8FD9;&#x91CC;&#x6709;&#x51E0;&#x4E2A;&#xFF1A;</p>
<table class="multi">
<caption class="cap">Table 16-2: Linux Storage Device Names</caption>
<tr>
<th class="title">Pattern</th>
<th class="title">Device</th>
</tr>
<tr>
<td valign="top" width="15%">/dev/fd* </td>
<td valign="top">Floppy disk drives</td>
</tr>
<tr>
<td valign="top">/dev/hd* </td>
<td valign="top">IDE (PATA) disks on older systems. Typical motherboards
contain two IDE connectors or channels, each with a cable with
two attachment points for drives. The first drive on the cable is
called the master device and the second is called the slave
device. The device names are ordered such that /dev/hda
refers to the master device on the first channel, /dev/hdb is the
slave device on the first channel; /dev/hdc, the master device
on the second channel, and so on. A trailing digit indicates the
partition number on the device. For example, /dev/hda1 refers
to the first partition on the first hard drive on the system while /
dev/hda refers to the entire drive.</td>
</tr>
<tr>
<td valign="top">/dev/lp* </td>
<td valign="top">Printers</td>
</tr>
<tr>
<td valign="top">/dev/sd* </td>
<td valign="top">SCSI disks. On recent Linux systems, the kernel treats all disk-
like devices (including PATA/SATA hard disks, flash drives, and
USB mass storage devices, such as portable music players and
digital cameras) as SCSI disks. The rest of the naming system is
similar to the older /dev/hd* naming scheme described above.</td>
</tr>
<tr>
<td valign="top">/dev/sr* </td>
<td valign="top">Optical drives (CD/DVD readers and burners)</td>
</tr>
</table>

<table class="multi">
<caption class="cap"> &#x8868;16-2: Linux &#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x540D;&#x79F0;</caption>
<tr>
<th class="title">&#x6A21;&#x5F0F;</th>
<th class="title">&#x8BBE;&#x5907;</th>
</tr>
<tr>
<td valign="top" width="15%">/dev/fd* </td>
<td valign="top">&#x8F6F;&#x76D8;&#x9A71;&#x52A8;&#x5668;</td>
</tr>
<tr>
<td valign="top">/dev/hd* </td>
<td valign="top">&#x8001;&#x7CFB;&#x7EDF;&#x4E2D;&#x7684; IDE(PATA)&#x78C1;&#x76D8;&#x3002;&#x5178;&#x578B;&#x7684;&#x4E3B;&#x677F;&#x5305;&#x542B;&#x4E24;&#x4E2A; IDE &#x8FDE;&#x63A5;&#x5668;&#x6216;&#x8005;&#x662F;&#x901A;&#x9053;&#xFF0C;&#x6BCF;&#x4E2A;&#x8FDE;&#x63A5;&#x5668;
&#x5E26;&#x6709;&#x4E00;&#x6839;&#x7F06;&#x7EBF;&#xFF0C;&#x6BCF;&#x6839;&#x7F06;&#x7EBF;&#x4E0A;&#x6709;&#x4E24;&#x4E2A;&#x786C;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x8FDE;&#x63A5;&#x70B9;&#x3002;&#x7F06;&#x7EBF;&#x4E0A;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x9A71;&#x52A8;&#x5668;&#x53EB;&#x505A;&#x4E3B;&#x8BBE;&#x5907;&#xFF0C;
&#x7B2C;&#x4E8C;&#x4E2A;&#x53EB;&#x505A;&#x4ECE;&#x8BBE;&#x5907;&#x3002;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x8FD9;&#x6837;&#x5B89;&#x6392;&#xFF0C;/dev/hdb &#x662F;&#x6307;&#x7B2C;&#x4E00;&#x901A;&#x9053;&#x4E0A;&#x7684;&#x4E3B;&#x8BBE;&#x5907;&#x540D;&#xFF1B;/dev/hdb
&#x662F;&#x7B2C;&#x4E00;&#x901A;&#x9053;&#x4E0A;&#x7684;&#x4ECE;&#x8BBE;&#x5907;&#x540D;&#xFF1B;/dev/hdc &#x662F;&#x7B2C;&#x4E8C;&#x901A;&#x9053;&#x4E0A;&#x7684;&#x4E3B;&#x8BBE;&#x5907;&#x540D;&#xFF0C;&#x7B49;&#x7B49;&#x3002;&#x672B;&#x5C3E;&#x7684;&#x6570;&#x5B57;&#x8868;&#x793A;
&#x786C;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x4E0A;&#x7684;&#x5206;&#x533A;&#x3002;&#x4F8B;&#x5982;&#xFF0C;/dev/hda1&#x662F;&#x6307;&#x7CFB;&#x7EDF;&#x4E2D;&#x7B2C;&#x4E00;&#x786C;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x4E0A;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x5206;&#x533A;&#xFF0C;&#x800C;
/dev/hda &#x5219;&#x662F;&#x6307;&#x6574;&#x4E2A;&#x786C;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x3002;</td>
</tr>
<tr>
<td valign="top">/dev/lp* </td>
<td valign="top">&#x6253;&#x5370;&#x673A;</td>
</tr>
<tr>
<td valign="top">/dev/sd* </td>
<td valign="top">
SCSI &#x78C1;&#x76D8;&#x3002;&#x5728;&#x6700;&#x8FD1;&#x7684; Linux &#x7CFB;&#x7EDF;&#x4E2D;&#xFF0C;&#x5185;&#x6838;&#x628A;&#x6240;&#x6709;&#x7C7B;&#x4F3C;&#x4E8E;&#x78C1;&#x76D8;&#x7684;&#x8BBE;&#x5907;&#xFF08;&#x5305;&#x62EC; PATA/SATA &#x786C;&#x76D8;&#xFF0C;
&#x95EA;&#x5B58;&#xFF0C;&#x548C; USB &#x5B58;&#x50A8;&#x8BBE;&#x5907;&#xFF0C;&#x6BD4;&#x5982;&#x8BF4;&#x53EF;&#x79FB;&#x52A8;&#x7684;&#x97F3;&#x4E50;&#x64AD;&#x653E;&#x5668;&#x548C;&#x6570;&#x7801;&#x76F8;&#x673A;&#xFF09;&#x770B;&#x4F5C; SCSI &#x78C1;&#x76D8;&#x3002;
&#x5269;&#x4E0B;&#x7684;&#x547D;&#x540D;&#x7CFB;&#x7EDF;&#x7C7B;&#x4F3C;&#x4E8E;&#x4E0A;&#x8FF0;&#x6240;&#x63CF;&#x8FF0;&#x7684;&#x65E7;&#x7684;/dev/hd*&#x547D;&#x540D;&#x65B9;&#x6848;&#x3002;</td>
</tr>
<tr>
<td valign="top">/dev/sr* </td>
<td valign="top">&#x5149;&#x76D8;&#xFF08;CD/DVD &#x8BFB;&#x53D6;&#x5668;&#x548C;&#x70E7;&#x5199;&#x5668;&#xFF09;</td>
</tr>
</table>

<p>In addition, we often see symbolic links such as /dev/cdrom, /dev/dvd and /dev/
floppy, which point to the actual device files, provided as a convenience.
If you are working on a system that does not automatically mount removable devices,
you can use the following technique to determine how the removable device is named
when it is attached. First, start a real-time view of the /var/log/messages file (you
may require superuser privileges for this):</p>
<p>&#x53E6;&#x5916;&#xFF0C;&#x6211;&#x4EEC;&#x7ECF;&#x5E38;&#x770B;&#x5230;&#x7B26;&#x53F7;&#x94FE;&#x63A5;&#x6BD4;&#x5982;&#x8BF4;/dev/cdrom&#xFF0C;/dev/dvd &#x548C;/dev/floppy&#xFF0C;&#x5B83;&#x4EEC;&#x6307;&#x5411;&#x5B9E;&#x9645;&#x7684;
&#x8BBE;&#x5907;&#x6587;&#x4EF6;&#xFF0C;&#x63D0;&#x4F9B;&#x8FD9;&#x4E9B;&#x94FE;&#x63A5;&#x662F;&#x4E3A;&#x4E86;&#x65B9;&#x4FBF;&#x4F7F;&#x7528;&#x3002;&#x5982;&#x679C;&#x4F60;&#x5DE5;&#x4F5C;&#x7684;&#x7CFB;&#x7EDF;&#x4E0D;&#x80FD;&#x81EA;&#x52A8;&#x6302;&#x8F7D;&#x53EF;&#x79FB;&#x52A8;&#x7684;&#x8BBE;&#x5907;&#xFF0C;&#x4F60;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;
&#x4E0B;&#x9762;&#x7684;&#x6280;&#x5DE7;&#x6765;&#x51B3;&#x5B9A;&#x5F53;&#x53EF;&#x79FB;&#x52A8;&#x8BBE;&#x5907;&#x8FDE;&#x63A5;&#x540E;&#xFF0C;&#x5B83;&#x662F;&#x600E;&#x6837;&#x88AB;&#x547D;&#x540D;&#x7684;&#x3002;&#x9996;&#x5148;&#xFF0C;&#x542F;&#x52A8;&#x4E00;&#x4E2A;&#x5B9E;&#x65F6;&#x67E5;&#x770B;&#x6587;&#x4EF6;/var/log/messages
&#xFF08;&#x4F60;&#x53EF;&#x80FD;&#x9700;&#x8981;&#x8D85;&#x7EA7;&#x7528;&#x6237;&#x6743;&#x9650;&#xFF09;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ sudo tail -f /var/log/messages
</code></pre><p>The last few lines of the file will be displayed and then pause. Next, plug in the
removable device. In this example, we will use a 16 MB flash drive. Almost
immediately, the kernel will notice the device and probe it:</p>
<p>&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#x7684;&#x6700;&#x540E;&#x51E0;&#x884C;&#x4F1A;&#x88AB;&#x663E;&#x793A;&#xFF0C;&#x7136;&#x540E;&#x505C;&#x6B62;&#x3002;&#x4E0B;&#x4E00;&#x6B65;&#xFF0C;&#x63D2;&#x5165;&#x8FD9;&#x4E2A;&#x53EF;&#x79FB;&#x52A8;&#x7684;&#x8BBE;&#x5907;&#x3002;&#x5728;
&#x8FD9;&#x4E2A;&#x4F8B;&#x5B50;&#x91CC;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x4F7F;&#x7528;&#x4E00;&#x4E2A;16MB &#x95EA;&#x5B58;&#x3002;&#x77AC;&#x95F4;&#xFF0C;&#x5185;&#x6838;&#x5C31;&#x4F1A;&#x53D1;&#x73B0;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#xFF0C;
&#x5E76;&#x4E14;&#x63A2;&#x6D4B;&#x5B83;&#xFF1A;</p>
<pre><code>Jul 23 10:07:53 linuxbox kernel: usb 3-2: new full speed USB device
using uhci_hcd and address 2
Jul 23 10:07:53 linuxbox kernel: usb 3-2: configuration #1 chosen
from 1 choice
Jul 23 10:07:53 linuxbox kernel: scsi3 : SCSI emulation for USB Mass
Storage devices
Jul 23 10:07:58 linuxbox kernel: scsi scan: INQUIRY result too short
(5), using 36
Jul 23 10:07:58 linuxbox kernel: scsi 3:0:0:0: Direct-Access Easy
Disk 1.00 PQ: 0 ANSI: 2
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte
hardware sectors (16 MB)
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is
off
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive
cache: write through
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] 31263 512-byte
hardware sectors (16 MB)
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Write Protect is
off
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Assuming drive
cache: write through
Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: Attached scsi generic
sg3 type 0
</code></pre><p>After the display pauses again, type Ctrl-c to get the prompt back. The interesting parts
of the output are the repeated references to &#x201C;[sdb]&#x201D; which matches our expectation of a
SCSI disk device name. Knowing this, two lines become particularly illuminating:</p>
<p>&#x663E;&#x793A;&#x518D;&#x6B21;&#x505C;&#x6B62;&#x4E4B;&#x540E;&#xFF0C;&#x8F93;&#x5165; Ctrl-c&#xFF0C;&#x91CD;&#x65B0;&#x5F97;&#x5230;&#x63D0;&#x793A;&#x7B26;&#x3002;&#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x7684;&#x6709;&#x8DA3;&#x90E8;&#x5206;&#x662F;&#x4E00;&#x518D;&#x63D0;&#x53CA;&#x201C;[sdb]&#x201D;&#xFF0C;
&#x8FD9;&#x6B63;&#x597D;&#x7B26;&#x548C;&#x6211;&#x4EEC;&#x671F;&#x671B;&#x7684; SCSI &#x78C1;&#x76D8;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x3002;&#x77E5;&#x9053;&#x8FD9;&#x4E00;&#x70B9;&#x540E;&#xFF0C;&#x6709;&#x4E24;&#x884C;&#x8F93;&#x51FA;&#x53D8;&#x5F97;&#x9887;&#x5177;&#x542F;&#x53D1;&#x6027;&#xFF1A;</p>
<pre><code>Jul 23 10:07:59 linuxbox kernel: sdb: sdb1
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI
removable disk
</code></pre><p>This tells us the device name is /dev/sdb for the entire device and /dev/sdb1 for
the first partition on the device. As we have seen, working with Linux is full of
interesting detective work!</p>
<p>&#x8FD9;&#x544A;&#x8BC9;&#x6211;&#x4EEC;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x662F;/dev/sdb &#x6307;&#x6574;&#x4E2A;&#x8BBE;&#x5907;&#xFF0C;/dev/sdb1&#x662F;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x7684;&#x7B2C;&#x4E00;&#x5206;&#x533A;&#x3002;
&#x6B63;&#x5982;&#x6211;&#x4EEC;&#x6240;&#x770B;&#x5230;&#x7684;&#xFF0C;&#x4F7F;&#x7528; Linux &#x7CFB;&#x7EDF;&#x5145;&#x6EE1;&#x4E86;&#x6709;&#x8DA3;&#x7684;&#x76D1;&#x6D4B;&#x5DE5;&#x4F5C;&#x3002;</p>
<p>Tip: Using the tail -f /var/log/messages technique is a great way to
watch what the system is doing in near real-time.</p>
<p>&#x5C0F;&#x8D34;&#x58EB;&#xFF1A;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A; tail -f /var/log/messages &#x6280;&#x5DE7;&#x662F;&#x4E00;&#x4E2A;&#x5F88;&#x4E0D;&#x9519;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x53EF;&#x4EE5;&#x5B9E;&#x65F6;
&#x89C2;&#x5BDF;&#x7CFB;&#x7EDF;&#x7684;&#x4E00;&#x4E3E;&#x4E00;&#x52A8;&#x3002;</p>
<p>With our device name in hand, we can now mount the flash drive:</p>
<p>&#x65E2;&#x7136;&#x77E5;&#x9053;&#x4E86;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x53EF;&#x4EE5;&#x6302;&#x8F7D;&#x8FD9;&#x4E2A;&#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#x4E86;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ sudo mkdir /mnt/flash
[me@linuxbox ~]$ sudo mount /dev/sdb1 /mnt/flash
[me@linuxbox ~]$ df
Filesystem      1K-blocks   Used        Available   Use%    Mounted on
/dev/sda2       15115452    5186944     9775164     35%     /
/dev/sda5       59631908    31777376    24776480    57%     /home
/dev/sda1       147764      17277       122858      13%     /boot
tmpfs           776808      0           776808      0%      /dev/shm
/dev/sdb1       15560       0           15560       0%      /mnt/flash
</code></pre><p>The device name will remain the same as long as it remains physically attached to the
computer and the computer is not rebooted.</p>
<p>&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x4F1A;&#x4FDD;&#x6301;&#x4E0D;&#x53D8;&#x53EA;&#x8981;&#x8BBE;&#x5907;&#x4E0E;&#x8BA1;&#x7B97;&#x673A;&#x4FDD;&#x6301;&#x8FDE;&#x63A5;&#x5E76;&#x4E14;&#x8BA1;&#x7B97;&#x673A;&#x4E0D;&#x4F1A;&#x91CD;&#x65B0;&#x542F;&#x52A8;&#x3002;</p>
<h3 id="&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;">&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;</h3>
<p>Let&apos;s say that we want to reformat the flash drive with a Linux native file system, rather
than the FAT32 system it has now. This involves two steps: 1. (optional) create a new
partition layout if the existing one is not to our liking, and 2. create a new, empty file
system on the drive.</p>
<p>&#x5047;&#x82E5;&#x6211;&#x4EEC;&#x60F3;&#x8981;&#x7528; Linux &#x672C;&#x5730;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6765;&#x91CD;&#x65B0;&#x683C;&#x5F0F;&#x5316;&#x8FD9;&#x4E2A;&#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x5B83;&#x73B0;&#x7528;&#x7684; FAT32&#x7CFB;&#x7EDF;&#x3002;
&#x8FD9;&#x6D89;&#x53CA;&#x5230;&#x4E24;&#x4E2A;&#x6B65;&#x9AA4;&#xFF1A;1.&#xFF08;&#x53EF;&#x9009;&#x7684;&#xFF09;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x5206;&#x533A;&#x5E03;&#x5C40;&#x82E5;&#x5DF2;&#x5B58;&#x5728;&#x7684;&#x5206;&#x533A;&#x4E0D;&#x662F;&#x6211;&#x4EEC;&#x559C;&#x6B22;&#x7684;&#x3002;2.
&#x5728;&#x8FD9;&#x4E2A;&#x95EA;&#x5B58;&#x4E0A;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x7A7A;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;</p>
<p>Warning! In the following exercise, we are going to format a flash drive. Use a
drive that contains nothing you care about because it will be erased! Again, make
absolutely sure you are specifying the correct device name for your system, not
the one shown in the text. Failure to heed this warning could result in you
formatting (i.e., erasing) the wrong drive!</p>
<p>&#x6CE8;&#x610F;&#xFF01;&#x5728;&#x4E0B;&#x9762;&#x7684;&#x7EC3;&#x4E60;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x8981;&#x683C;&#x5F0F;&#x5316;&#x4E00;&#x4E2A;&#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#x3002;&#x62FF;&#x4E00;&#x4E2A;&#x4E0D;&#x5305;&#x542B;&#x6709;&#x7528;&#x6570;&#x636E;&#x7684;&#x9A71;&#x52A8;&#x5668;
&#x4F5C;&#x4E3A;&#x5B9E;&#x9A8C;&#x54C1;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x5C06;&#x4F1A;&#x88AB;&#x64E6;&#x9664;&#xFF01;&#x518D;&#x6B21;&#xFF0C;&#x8BF7;&#x786E;&#x5B9A;&#x4F60;&#x6307;&#x5B9A;&#x4E86;&#x6B63;&#x786E;&#x7684;&#x7CFB;&#x7EDF;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x3002;&#x672A;&#x80FD;&#x6CE8;&#x610F;&#x6B64;
&#x8B66;&#x544A;&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x4F60;&#x683C;&#x5F0F;&#x5316;&#xFF08;&#x5373;&#x64E6;&#x9664;&#xFF09;&#x9519;&#x8BEF;&#x7684;&#x9A71;&#x52A8;&#x5668;&#xFF01;</p>
<h3 id="&#x7528;-fdisk-&#x547D;&#x4EE4;&#x64CD;&#x4F5C;&#x5206;&#x533A;">&#x7528; fdisk &#x547D;&#x4EE4;&#x64CD;&#x4F5C;&#x5206;&#x533A;</h3>
<p>The fdisk program allows us to interact directly with disk-like devices (such as hard
disk drives and flash drives) at a very low level. With this tool we can edit, delete, and
create partitions on the device. To work with our flash drive, we must first unmount it (if
needed) and then invoke the fdisk program as follows:</p>
<p>&#x8FD9;&#x4E2A; fdisk &#x7A0B;&#x5E8F;&#x5141;&#x8BB8;&#x6211;&#x4EEC;&#x76F4;&#x63A5;&#x5728;&#x5E95;&#x5C42;&#x4E0E;&#x7C7B;&#x4F3C;&#x78C1;&#x76D8;&#x7684;&#x8BBE;&#x5907;&#xFF08;&#x6BD4;&#x5982;&#x8BF4;&#x786C;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x548C;&#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#xFF09;&#x8FDB;&#x884C;&#x4EA4;&#x4E92;&#x3002;
&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;&#x5DE5;&#x5177;&#x53EF;&#x4EE5;&#x5728;&#x8BBE;&#x5907;&#x4E0A;&#x7F16;&#x8F91;&#xFF0C;&#x5220;&#x9664;&#xFF0C;&#x548C;&#x521B;&#x5EFA;&#x5206;&#x533A;&#x3002;&#x4EE5;&#x6211;&#x4EEC;&#x7684;&#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#x4E3A;&#x4F8B;&#xFF0C;
&#x9996;&#x5148;&#x6211;&#x4EEC;&#x5FC5;&#x987B;&#x5378;&#x8F7D;&#x5B83;&#xFF08;&#x5982;&#x679C;&#x9700;&#x8981;&#x7684;&#x8BDD;&#xFF09;&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528; fdisk &#x7A0B;&#x5E8F;&#xFF0C;&#x5982;&#x4E0B;&#x6240;&#x793A;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ sudo umount /dev/sdb1
[me@linuxbox ~]$ sudo fdisk /dev/sdb
</code></pre><p>Notice that we must specify the device in terms of the entire device, not by partition
number. After the program starts up, we will see the following prompt:</p>
<p>&#x6CE8;&#x610F;&#x6211;&#x4EEC;&#x5FC5;&#x987B;&#x6307;&#x5B9A;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#xFF0C;&#x5C31;&#x6574;&#x4E2A;&#x8BBE;&#x5907;&#x800C;&#x8A00;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x901A;&#x8FC7;&#x5206;&#x533A;&#x53F7;&#x3002;&#x8FD9;&#x4E2A;&#x7A0B;&#x5E8F;&#x542F;&#x52A8;&#x540E;&#xFF0C;&#x6211;&#x4EEC;
&#x5C06;&#x770B;&#x5230;&#x4EE5;&#x4E0B;&#x63D0;&#x793A;&#xFF1A;</p>
<pre><code>Command (m for help):
</code></pre><p>Entering an &#x201C;m&#x201D; will display the program menu:</p>
<p>&#x8F93;&#x5165;&quot;m&quot;&#x4F1A;&#x663E;&#x793A;&#x7A0B;&#x5E8F;&#x83DC;&#x5355;&#xFF1A;</p>
<pre><code>Command action
a       toggle a bootable flag
....
</code></pre><p>The first thing we want to do is examine the existing partition layout. We do this by
entering &#x201C;p&#x201D; to print the partition table for the device:</p>
<p>&#x6211;&#x4EEC;&#x60F3;&#x8981;&#x505A;&#x7684;&#x7B2C;&#x4E00;&#x4EF6;&#x4E8B;&#x60C5;&#x662F;&#x68C0;&#x67E5;&#x5DF2;&#x5B58;&#x5728;&#x7684;&#x5206;&#x533A;&#x5E03;&#x5C40;&#x3002;&#x8F93;&#x5165;&quot;p&quot;&#x4F1A;&#x6253;&#x5370;&#x51FA;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x7684;&#x5206;&#x533A;&#x8868;&#xFF1A;</p>
<pre><code>Command (m for help): p

Disk /dev/sdb: 16 MB, 16006656 bytes
1 heads, 31 sectors/track, 1008 cylinders
Units = cylinders of 31 * 512 = 15872 bytes

Device Boot     Start        End     Blocks   Id        System
/dev/sdb1           2       1008      15608+   b       w95 FAT32
</code></pre><p>In this example, we see a 16 MB device with a single partition (1) that uses 1006 of the
available 1008 cylinders on the device. The partition is identified as Windows 95 FAT32
partition. Some programs will use this identifier to limit the kinds of operation that can
be done to the disk, but most of the time it is not critical to change it. However, in the
interest of demonstration, we will change it to indicate a Linux partition. To do this, we
must first find out what ID is used to identify a Linux partition. In the listing above, we
see that the ID &#x201C;b&#x201D; is used to specify the exiting partition. To see a list of the available
partition types, we refer back to the program menu. There we can see the following
choice:</p>
<p>&#x5728;&#x6B64;&#x4F8B;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x770B;&#x5230;&#x4E00;&#x4E2A;16MB &#x7684;&#x8BBE;&#x5907;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x5206;&#x533A;(1)&#xFF0C;&#x6B64;&#x5206;&#x533A;&#x5360;&#x7528;&#x4E86;&#x53EF;&#x7528;&#x7684;1008&#x4E2A;&#x67F1;&#x9762;&#x4E2D;&#x7684;1006&#x4E2A;,
&#x5E76;&#x88AB;&#x6807;&#x8BC6;&#x4E3A; Windows 95 FAT32&#x5206;&#x533A;&#x3002;&#x6709;&#x4E9B;&#x7A0B;&#x5E8F;&#x4F1A;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;&#x6807;&#x5FD7;&#x7B26;&#x6765;&#x9650;&#x5236;&#x4E00;&#x4E9B;&#x53EF;&#x4EE5;&#x5BF9;&#x78C1;&#x76D8;&#x6240;&#x505A;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;
&#x4F46;&#x5927;&#x591A;&#x6570;&#x60C5;&#x51B5;&#x4E0B;&#x66F4;&#x6539;&#x8FD9;&#x4E2A;&#x6807;&#x5FD7;&#x7B26;&#x6CA1;&#x6709;&#x5371;&#x5BB3;&#x3002;&#x7136;&#x800C;&#xFF0C;&#x4E3A;&#x4E86;&#x53D9;&#x8FF0;&#x65B9;&#x4FBF;&#xFF0C;&#x6211;&#x4EEC;&#x5C06;&#x4F1A;&#x66F4;&#x6539;&#x5B83;&#xFF0C;
&#x4EE5;&#x6B64;&#x6765;&#x8868;&#x660E;&#x662F;&#x4E2A; Linux &#x5206;&#x533A;&#x3002;&#x5728;&#x66F4;&#x6539;&#x4E4B;&#x524D;&#xFF0C;&#x9996;&#x5148;&#x6211;&#x4EEC;&#x5FC5;&#x987B;&#x627E;&#x5230;&#x88AB;&#x7528;&#x6765;&#x8BC6;&#x522B;&#x4E00;&#x4E2A; Linux &#x5206;&#x533A;&#x7684; ID &#x53F7;&#x7801;&#x3002;
&#x5728;&#x4E0A;&#x9762;&#x5217;&#x8868;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x770B;&#x5230; ID &#x53F7;&#x7801;&#x201C;b&#x201D;&#x88AB;&#x7528;&#x6765;&#x6307;&#x5B9A;&#x8FD9;&#x4E2A;&#x5DF2;&#x5B58;&#x5728;&#x7684;&#x5206;&#x533A;&#x3002;&#x8981;&#x67E5;&#x770B;&#x53EF;&#x7528;&#x7684;&#x5206;&#x533A;&#x7C7B;&#x578B;&#x5217;&#x8868;&#xFF0C;
&#x53C2;&#x8003;&#x4E4B;&#x524D;&#x7684;&#x7A0B;&#x5E8F;&#x83DC;&#x5355;&#x3002;&#x6211;&#x4EEC;&#x4F1A;&#x770B;&#x5230;&#x4EE5;&#x4E0B;&#x9009;&#x9879;&#xFF1A;</p>
<pre><code>l   list known partition types
</code></pre><p>If we enter &#x201C;l&#x201D; at the prompt, a large list of possible types is displayed. Among them we
see &#x201C;b&#x201D; for our existing partition type and &#x201C;83&#x201D; for Linux.</p>
<p>&#x5982;&#x679C;&#x6211;&#x4EEC;&#x5728;&#x63D0;&#x793A;&#x7B26;&#x4E0B;&#x8F93;&#x5165;&#x201C;l&#x201D;&#xFF0C;&#x5C31;&#x4F1A;&#x663E;&#x793A;&#x4E00;&#x4E2A;&#x5F88;&#x957F;&#x7684;&#x53EF;&#x80FD;&#x7C7B;&#x578B;&#x5217;&#x8868;&#x3002;&#x5728;&#x5B83;&#x4EEC;&#x4E4B;&#x4E2D;&#x4F1A;&#x770B;&#x5230;&#x201C;b&#x201D;&#x4E3A;&#x5DF2;&#x5B58;&#x5728;&#x5206;&#x533A;
&#x7C7B;&#x578B;&#x7684; ID &#x53F7;&#xFF0C;&#x800C;&#x201C;83&#x201D;&#x662F;&#x9488;&#x5BF9; Linux &#x7CFB;&#x7EDF;&#x7684; ID &#x53F7;&#x3002;</p>
<p>Going back to the menu, we see this choice to change a partition ID:</p>
<p>&#x56DE;&#x5230;&#x4E4B;&#x524D;&#x7684;&#x83DC;&#x5355;&#xFF0C;&#x770B;&#x5230;&#x8FD9;&#x4E2A;&#x9009;&#x9879;&#x6765;&#x66F4;&#x6539;&#x5206;&#x533A; ID &#x53F7;&#xFF1A;</p>
<pre><code>t   change a partition&apos;s system id
</code></pre><p>We enter &#x201C;t&#x201D; at the prompt enter the new ID:</p>
<p>&#x6211;&#x4EEC;&#x5148;&#x8F93;&#x5165;&#x201C;t&#x201D;&#xFF0C;&#x518D;&#x8F93;&#x5165;&#x65B0;&#x7684; ID &#x53F7;&#xFF1A;</p>
<pre><code>Command (m for help): t
Selected partition 1
Hex code (type L to list codes): 83
Changed system type of partition 1 to 83 (Linux)
</code></pre><p>This completes all the changes that we need to make. Up to this point, the device has
been untouched (all the changes have been stored in memory, not on the physical device),
so we will write the modified partition table to the device and exit. To do this, we enter
&#x201C;w&#x201D; at the prompt:</p>
<p>&#x8FD9;&#x5C31;&#x5B8C;&#x6210;&#x4E86;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x505A;&#x5F97;&#x6240;&#x6709;&#x4FEE;&#x6539;&#x3002;&#x5230;&#x76EE;&#x524D;&#x4E3A;&#x6B62;&#xFF0C;&#x8FD8;&#x6CA1;&#x6709;&#x63A5;&#x89E6;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#xFF08;&#x6240;&#x6709;&#x4FEE;&#x6539;&#x90FD;&#x5B58;&#x50A8;&#x5728;&#x5185;&#x5B58;&#x4E2D;&#xFF0C;
&#x800C;&#x4E0D;&#x662F;&#x5728;&#x6B64;&#x7269;&#x7406;&#x8BBE;&#x5907;&#x4E2D;&#xFF09;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x5C06;&#x4F1A;&#x628A;&#x4FEE;&#x6539;&#x8FC7;&#x7684;&#x5206;&#x533A;&#x8868;&#x5199;&#x5165;&#x6B64;&#x8BBE;&#x5907;&#xFF0C;&#x518D;&#x9000;&#x51FA;&#x3002;&#x4E3A;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x8F93;&#x5165;
&#x5728;&#x63D0;&#x793A;&#x7B26;&#x4E0B;&#x8F93;&#x5165;&quot;w&quot;:</p>
<pre><code>Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
WARNING: If you have created or modified any DOS 6.x
partitions, please see the fdisk manual page for additional
information.
Syncing disks.
[me@linuxbox ~]$
</code></pre><p>If we had decided to leave the device unaltered, we could have entered &#x201C;q&#x201D; at the prompt,
which would have exited the program without writing the changes. We can safely ignore
the ominous sounding warning message.</p>
<p>&#x5982;&#x679C;&#x6211;&#x4EEC;&#x5DF2;&#x7ECF;&#x51B3;&#x5B9A;&#x4FDD;&#x6301;&#x8BBE;&#x5907;&#x4E0D;&#x53D8;&#xFF0C;&#x53EF;&#x5728;&#x63D0;&#x793A;&#x7B26;&#x4E0B;&#x8F93;&#x5165;&quot;q&quot;&#xFF0C;&#x8FD9;&#x5C06;&#x9000;&#x51FA;&#x7A0B;&#x5E8F;&#x800C;&#x6CA1;&#x6709;&#x5199;&#x66F4;&#x6539;&#x3002;&#x6211;&#x4EEC;
&#x53EF;&#x4EE5;&#x5B89;&#x5168;&#x5730;&#x5FFD;&#x7565;&#x8FD9;&#x4E9B;&#x4E0D;&#x7965;&#x7684;&#x8B66;&#x544A;&#x4FE1;&#x606F;&#x3002;</p>
<h3 id="&#x7528;-mkfs-&#x547D;&#x4EE4;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;">&#x7528; mkfs &#x547D;&#x4EE4;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;</h3>
<p>With our partition editing done (lightweight though it might have been) it&#x2019;s time to create
a new file system on our flash drive. To do this, we will use mkfs (short for &#x201C;make file
system&#x201D;), which can create file systems in a variety of formats. To create an ext3 file
system on the device, we use the &#x201C;-t&#x201D; option to specify the &#x201C;ext3&#x201D; system type, followed
by the name of device containing the partition we wish to format:</p>
<p>&#x5B8C;&#x6210;&#x4E86;&#x5206;&#x533A;&#x7F16;&#x8F91;&#x5DE5;&#x4F5C;&#xFF08;&#x5B83;&#x6216;&#x8BB8;&#x662F;&#x8F7B;&#x91CF;&#x7EA7;&#x7684;&#xFF09;&#xFF0C;&#x662F;&#x65F6;&#x5019;&#x5728;&#x6211;&#x4EEC;&#x7684;&#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#x4E0A;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x4E86;&#x3002;
&#x4E3A;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x4F1A;&#x4F7F;&#x7528; mkfs&#xFF08;&quot;make file system&quot;&#x7684;&#x7B80;&#x5199;&#xFF09;&#xFF0C;&#x5B83;&#x80FD;&#x521B;&#x5EFA;&#x5404;&#x79CD;&#x683C;&#x5F0F;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;
&#x5728;&#x6B64;&#x8BBE;&#x5907;&#x4E0A;&#x521B;&#x5EFA;&#x4E00;&#x4E2A; ext3&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF0C;&#x6211;&#x4EEC;&#x4F7F;&#x7528;&quot;-t&quot;
&#x9009;&#x9879;&#x6765;&#x6307;&#x5B9A;&#x8FD9;&#x4E2A;&quot;ext3&quot;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#xFF0C;&#x968F;&#x540E;&#x662F;&#x6211;&#x4EEC;&#x8981;&#x683C;&#x5F0F;&#x5316;&#x7684;&#x8BBE;&#x5907;&#x5206;&#x533A;&#x540D;&#x79F0;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ sudo mkfs -t ext3 /dev/sdb1
mke2fs 1.40.2 (12-Jul-2007)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
3904 inodes, 15608 blocks
780 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=15990784
2 block groups
8192 blocks per group, 8192 fragments per group
1952 inodes per group
Superblock backups stored on blocks:
8193
Writing inode tables: done
Creating journal (1024 blocks): done
Writing superblocks and filesystem accounting information: done
This filesystem will be automatically checked every 34 mounts or
180 days, whichever comes first. Use tune2fs -c or -i to override.
[me@linuxbox ~]$
</code></pre><p>The program will display a lot of information when ext3 is the chosen file system type.
To re-format the device to its original FAT32 file system, specify &#x201C;vfat&#x201D; as the file system
type:</p>
<p>&#x5F53; ext3&#x88AB;&#x9009;&#x4E3A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#x65F6;&#xFF0C;&#x8FD9;&#x4E2A;&#x7A0B;&#x5E8F;&#x4F1A;&#x663E;&#x793A;&#x8BB8;&#x591A;&#x4FE1;&#x606F;&#x3002;&#x82E5;&#x628A;&#x8FD9;&#x4E2A;&#x8BBE;&#x5907;&#x91CD;&#x65B0;&#x683C;&#x5F0F;&#x5316;&#x4E3A;&#x5B83;&#x6700;&#x521D;&#x7684; FAT32&#x6587;&#x4EF6;
&#x7CFB;&#x7EDF;&#xFF0C;&#x6307;&#x5B9A;&quot;vfat&quot;&#x4F5C;&#x4E3A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ sudo mkfs -t vfat /dev/sdb1
</code></pre><p>This process of partitioning and formatting can be used anytime additional storage
devices are added to the system. While we worked with a tiny flash drive, the same
process can be applied to internal hard disks and other removable storage devices like
USB hard drives.</p>
<p>&#x4EFB;&#x4F55;&#x65F6;&#x5019;&#x6DFB;&#x52A0;&#x989D;&#x5916;&#x7684;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x5230;&#x7CFB;&#x7EDF;&#x4E2D;&#x65F6;&#xFF0C;&#x90FD;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;&#x5206;&#x533A;&#x548C;&#x683C;&#x5F0F;&#x5316;&#x7684;&#x8FC7;&#x7A0B;&#x3002;&#x867D;&#x7136;&#x6211;&#x4EEC;
&#x53EA;&#x4EE5;&#x4E00;&#x4E2A;&#x5C0F;&#x5C0F;&#x7684;&#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#x4E3A;&#x4F8B;&#xFF0C;&#x540C;&#x6837;&#x7684;&#x64CD;&#x4F5C;&#x53EF;&#x4EE5;&#x88AB;&#x5E94;&#x7528;&#x5230;&#x5185;&#x90E8;&#x786C;&#x76D8;&#x548C;&#x5176;&#x5B83;&#x53EF;&#x79FB;&#x52A8;&#x7684;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x4E0A;
&#x50CF; USB &#x786C;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x3002;</p>
<h3 id="&#x6D4B;&#x8BD5;&#x548C;&#x4FEE;&#x590D;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;">&#x6D4B;&#x8BD5;&#x548C;&#x4FEE;&#x590D;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;</h3>
<p>In our earlier discussion of the /etc/fstab file, we saw some mysterious digits at the
end of each line. Each time the system boots, it routinely checks the integrity of the file
systems before mounting them. This is done by the fsck program (short for &#x201C;file system
check&#x201D;). The last number in each fstab entry specifies the order the devices are to be
checked. In our example above, we see that the root file system is checked first, followed
by the home and boot file systems. Devices with a zero as the last digit are not
routinely checked.</p>
<p>&#x5728;&#x4E4B;&#x524D;&#x8BA8;&#x8BBA;&#x6587;&#x4EF6;/etc/fstab &#x65F6;&#xFF0C;&#x6211;&#x4EEC;&#x4F1A;&#x5728;&#x6BCF;&#x884C;&#x7684;&#x672B;&#x5C3E;&#x770B;&#x5230;&#x4E00;&#x4E9B;&#x795E;&#x79D8;&#x7684;&#x6570;&#x5B57;&#x3002;&#x6BCF;&#x6B21;&#x7CFB;&#x7EDF;&#x542F;&#x52A8;&#x65F6;&#xFF0C;
&#x5728;&#x6302;&#x8F7D;&#x7CFB;&#x7EDF;&#x4E4B;&#x524D;&#xFF0C;&#x90FD;&#x4F1A;&#x6309;&#x7167;&#x60EF;&#x4F8B;&#x68C0;&#x67E5;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x5B8C;&#x6574;&#x6027;&#x3002;&#x8FD9;&#x4E2A;&#x4EFB;&#x52A1;&#x7531; fsck &#x7A0B;&#x5E8F;&#xFF08;&#x662F;&quot;file system
check&quot;&#x7684;&#x7B80;&#x5199;&#xFF09;&#x5B8C;&#x6210;&#x3002;&#x6BCF;&#x4E2A; fstab &#x9879;&#x4E2D;&#x7684;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x6570;&#x5B57;&#x6307;&#x5B9A;&#x4E86;&#x8BBE;&#x5907;&#x7684;&#x68C0;&#x67E5;&#x987A;&#x5E8F;&#x3002;
&#x5728;&#x4E0A;&#x9762;&#x7684;&#x5B9E;&#x4F8B;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x770B;&#x5230;&#x9996;&#x5148;&#x68C0;&#x67E5;&#x6839;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF0C;&#x7136;&#x540E;&#x662F; home &#x548C; boot &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;&#x82E5;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x6570;&#x5B57;
&#x662F;&#x96F6;&#x5219;&#x76F8;&#x5E94;&#x8BBE;&#x5907;&#x4E0D;&#x4F1A;&#x88AB;&#x68C0;&#x67E5;&#x3002;</p>
<p>In addition to checking the integrity of file systems, fsck can also repair corrupt file
systems with varying degrees of success, depending on the amount of damage. On Unix-
like file systems, recovered portions of files are placed in the lost+found directory,
located in the root of each file system.</p>
<p>&#x9664;&#x4E86;&#x68C0;&#x67E5;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7684;&#x5B8C;&#x6574;&#x6027;&#x4E4B;&#x5916;&#xFF0C;fsck &#x8FD8;&#x80FD;&#x4FEE;&#x590D;&#x53D7;&#x635F;&#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF0C;&#x5176;&#x6210;&#x529F;&#x5EA6;&#x4F9D;&#x8D56;&#x4E8E;&#x635F;&#x574F;&#x7684;&#x6570;&#x91CF;&#x3002;
&#x5728;&#x7C7B; Unix &#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x4E2D;&#xFF0C;&#x6587;&#x4EF6;&#x6062;&#x590D;&#x7684;&#x90E8;&#x5206;&#x88AB;&#x653E;&#x7F6E;&#x4E8E; lost+found &#x76EE;&#x5F55;&#x91CC;&#x9762;&#xFF0C;&#x4F4D;&#x4E8E;&#x6BCF;&#x4E2A;&#x6587;&#x4EF6;
&#x7CFB;&#x7EDF;&#x7684;&#x6839;&#x76EE;&#x5F55;&#x4E0B;&#x9762;&#x3002;</p>
<p>To check our flash drive (which should be unmounted first), we could do the following:</p>
<p>&#x68C0;&#x67E5;&#x6211;&#x4EEC;&#x7684;&#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#xFF08;&#x9996;&#x5148;&#x5E94;&#x8BE5;&#x5378;&#x8F7D;&#xFF09;&#xFF0C;&#x6211;&#x4EEC;&#x80FD;&#x6267;&#x884C;&#x4E0B;&#x9762;&#x7684;&#x64CD;&#x4F5C;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ sudo fsck /dev/sdb1
fsck 1.40.8 (13-Mar-2008)
e2fsck 1.40.8 (13-Mar-2008)
/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks
</code></pre><p>In my experience, file system corruption is quite rare unless there is a hardware problem,
such as a failing disk drive. On most systems, file system corruption detected at boot
time will cause the system to stop and direct you to run fsck before continuing.</p>
<p>&#x4EE5;&#x6211;&#x7684;&#x7ECF;&#x9A8C;&#xFF0C;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x635F;&#x574F;&#x60C5;&#x51B5;&#x76F8;&#x5F53;&#x7F55;&#x89C1;&#xFF0C;&#x9664;&#x975E;&#x786C;&#x4EF6;&#x5B58;&#x5728;&#x95EE;&#x9898;&#xFF0C;&#x5982;&#x78C1;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x6545;&#x969C;&#x3002;
&#x5728;&#x5927;&#x591A;&#x6570;&#x7CFB;&#x7EDF;&#x4E2D;&#xFF0C;&#x7CFB;&#x7EDF;&#x542F;&#x52A8;&#x9636;&#x6BB5;&#x82E5;&#x63A2;&#x6D4B;&#x5230;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x5DF2;&#x7ECF;&#x635F;&#x574F;&#x4E86;&#xFF0C;&#x5219;&#x4F1A;&#x5BFC;&#x81F4;&#x7CFB;&#x7EDF;&#x505C;&#x6B62;&#x4E0B;&#x6765;&#xFF0C;
&#x5728;&#x7CFB;&#x7EDF;&#x7EE7;&#x7EED;&#x6267;&#x884C;&#x4E4B;&#x524D;&#xFF0C;&#x4F1A;&#x6307;&#x5BFC;&#x4F60;&#x8FD0;&#x884C; fsck &#x7A0B;&#x5E8F;&#x3002;</p>
<blockquote>
<p>What The fsck?</p>
<p>&#x4EC0;&#x4E48;&#x662F; fsck?</p>
<p>In Unix culture, the word &#x201C;fsck&#x201D; is often used in place of a popular word with
which it shares three letters. This is especially appropriate, given that you will
probably be uttering the aforementioned word if you find yourself in a situation
where you are forced to run fsck.</p>
<p>&#x5728; Unix &#x6587;&#x5316;&#x4E2D;&#xFF0C;&quot;fsck&quot;&#x8FD9;&#x4E2A;&#x5355;&#x8BCD;&#x5F80;&#x5F80;&#x4F1A;&#x88AB;&#x7528;&#x6765;&#x4EE3;&#x66FF;&#x4E00;&#x4E2A;&#x6D41;&#x884C;&#x7684;&#x8BCD;&#xFF0C;&#x201C;fsck&#x201D;&#x548C;&#x8FD9;&#x4E2A;&#x8BCD;&#x5171;&#x4EAB;&#x4E86;&#x4E09;&#x4E2A;
&#x5B57;&#x6BCD;&#x3002;&#x8FD9;&#x4E2A;&#x5C24;&#x5176;&#x9002;&#x7528;&#xFF0C;&#x56E0;&#x4E3A;&#x4F60;&#x53EF;&#x80FD;&#x4F1A;&#x8BF4;&#x51FA;&#x4E0A;&#x6587;&#x63D0;&#x5230;&#x7684;&#x8BCD;&#xFF0C;&#x82E5;&#x4F60;&#x53D1;&#x73B0;&#x81EA;&#x5DF1;&#x5904;&#x4E8E;&#x8FD9;&#x79CD;&#x5883;&#x51B5;&#x4E0B;&#xFF0C;
&#x88AB;&#x5F3A;&#x5236;&#x6765;&#x8FD0;&#x884C; fsck &#x547D;&#x4EE4;&#x65F6;&#x3002;</p>
</blockquote>
<h3 id="&#x683C;&#x5F0F;&#x5316;&#x8F6F;&#x76D8;">&#x683C;&#x5F0F;&#x5316;&#x8F6F;&#x76D8;</h3>
<p>For those of us still using computers old enough to be equipped with floppy diskette
drives, we can manage those devices, too. Preparing a blank floppy for use is a two step
process. First, we perform a low-format on the diskette, then create a file system. To
accomplish the formatting, we use the fdformat program specifying the name of the
floppy device (usually /dev/fd0):</p>
<p>&#x5BF9;&#x4E8E;&#x90A3;&#x4E9B;&#x8FD8;&#x5728;&#x4F7F;&#x7528;&#x914D;&#x5907;&#x4E86;&#x8F6F;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x7684;&#x8BA1;&#x7B97;&#x673A;&#x7684;&#x7528;&#x6237;&#xFF0C;&#x6211;&#x4EEC;&#x4E5F;&#x80FD;&#x7BA1;&#x7406;&#x8FD9;&#x4E9B;&#x8BBE;&#x5907;&#x3002;&#x51C6;&#x5907;&#x4E00;
&#x5F20;&#x53EF;&#x7528;&#x7684;&#x7A7A;&#x767D;&#x8F6F;&#x76D8;&#x8981;&#x5206;&#x4E24;&#x4E2A;&#x6B65;&#x9AA4;&#x3002;&#x9996;&#x5148;&#xFF0C;&#x5BF9;&#x8FD9;&#x5F20;&#x8F6F;&#x76D8;&#x6267;&#x884C;&#x4F4E;&#x7EA7;&#x683C;&#x5F0F;&#x5316;&#xFF0C;&#x7136;&#x540E;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x3002;
&#x4E3A;&#x4E86;&#x5B8C;&#x6210;&#x683C;&#x5F0F;&#x5316;&#xFF0C;&#x6211;&#x4EEC;&#x4F7F;&#x7528; fdformat &#x7A0B;&#x5E8F;&#xFF0C;&#x540C;&#x65F6;&#x6307;&#x5B9A;&#x8F6F;&#x76D8;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#xFF08;&#x901A;&#x5E38;&#x4E3A;/dev/fd0&#xFF09;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ sudo fdformat /dev/fd0
Double-sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.
Formatting ... done
Verifying ... done
</code></pre><p>Next, we apply a FAT file system to the diskette with mkfs:</p>
<p>&#x63A5;&#x4E0B;&#x6765;&#xFF0C;&#x901A;&#x8FC7; mkfs &#x547D;&#x4EE4;&#xFF0C;&#x7ED9;&#x8FD9;&#x4E2A;&#x8F6F;&#x76D8;&#x521B;&#x5EFA;&#x4E00;&#x4E2A; FAT &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#xFF1A;</p>
<pre><code>[me@linuxbox ~]$ sudo mkfs -t msdos /dev/fd0
</code></pre><p>Notice that we use the &#x201C;msdos&#x201D; file system type to get the older (and smaller) style file
allocation tables. After a diskette is prepared, it may be mounted like other devices.</p>
<p>&#x6CE8;&#x610F;&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;&#x201C;msdos&#x201D;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#x6765;&#x5F97;&#x5230;&#x65E7;&#xFF08;&#x5C0F;&#x7684;&#xFF09;&#x98CE;&#x683C;&#x7684;&#x6587;&#x4EF6;&#x5206;&#x914D;&#x8868;&#x3002;&#x5F53;&#x4E00;&#x4E2A;&#x8F6F;&#x78C1;&#x76D8;
&#x88AB;&#x51C6;&#x5907;&#x597D;&#x4E4B;&#x540E;&#xFF0C;&#x5219;&#x53EF;&#x80FD;&#x50CF;&#x5176;&#x5B83;&#x8BBE;&#x5907;&#x4E00;&#x6837;&#x6302;&#x8F7D;&#x5B83;&#x3002;</p>
<h3 id="&#x76F4;&#x63A5;&#x628A;&#x6570;&#x636E;&#x79FB;&#x5165;&#x51FA;&#x8BBE;&#x5907;">&#x76F4;&#x63A5;&#x628A;&#x6570;&#x636E;&#x79FB;&#x5165;/&#x51FA;&#x8BBE;&#x5907;</h3>
<p>While we usually think of data on our computers as being organized into files, it is also
possible to think of the data in &#x201C;raw&#x201D; form. If we look at a disk drive, for example, we
see that it consists of a large number of &#x201C;blocks&#x201D; of data that the operating system sees as
directories and files. However, if we could treat a disk drive as simply a large collection
of data blocks, we could perform useful tasks, such as cloning devices.</p>
<p>&#x867D;&#x7136;&#x6211;&#x4EEC;&#x901A;&#x5E38;&#x8BA4;&#x4E3A;&#x8BA1;&#x7B97;&#x673A;&#x4E2D;&#x7684;&#x6570;&#x636E;&#x4EE5;&#x6587;&#x4EF6;&#x5F62;&#x5F0F;&#x6765;&#x7EC4;&#x7EC7;&#x6570;&#x636E;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x201C;&#x539F;&#x59CB;&#x7684;&#x201D;&#x5F62;&#x5F0F;&#x6765;&#x8003;&#x8651;&#x6570;&#x636E;&#x3002;
&#x5982;&#x679C;&#x6211;&#x4EEC;&#x770B;&#x4E00;&#x4E0B;&#x78C1;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#xFF0C;&#x4F8B;&#x5982;&#xFF0C;
&#x6211;&#x4EEC;&#x770B;&#x5230;&#x5B83;&#x7531;&#x5927;&#x91CF;&#x7684;&#x6570;&#x636E;&#x201C;&#x5757;&#x201D;&#x7EC4;&#x6210;&#xFF0C;&#x800C;&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x5374;&#x628A;&#x8FD9;&#x4E9B;&#x6570;&#x636E;&#x5757;&#x770B;&#x4F5C;&#x76EE;&#x5F55;&#x548C;&#x6587;&#x4EF6;&#x3002;&#x7136;&#x800C;&#xFF0C;&#x5982;&#x679C;
&#x628A;&#x78C1;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x7B80;&#x5355;&#x5730;&#x770B;&#x6210;&#x4E00;&#x4E2A;&#x6570;&#x636E;&#x5757;&#x5927;&#x96C6;&#x5408;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x80FD;&#x6267;&#x884C;&#x6709;&#x7528;&#x7684;&#x4EFB;&#x52A1;&#xFF0C;&#x5982;&#x514B;&#x9686;&#x8BBE;&#x5907;&#x3002;</p>
<p>The dd program performs this task. It copies blocks of data from one place to another. It
uses a unique syntax (for historical reasons) and is usually used this way:</p>
<p>&#x8FD9;&#x4E2A; dd &#x7A0B;&#x5E8F;&#x80FD;&#x6267;&#x884C;&#x6B64;&#x4EFB;&#x52A1;&#x3002;&#x5B83;&#x53EF;&#x4EE5;&#x628A;&#x6570;&#x636E;&#x5757;&#x4ECE;&#x4E00;&#x4E2A;&#x5730;&#x65B9;&#x590D;&#x5236;&#x5230;&#x53E6;&#x4E00;&#x4E2A;&#x5730;&#x65B9;&#x3002;&#x5B83;&#x4F7F;&#x7528;&#x72EC;&#x7279;&#x7684;&#x8BED;&#x6CD5;&#xFF08;&#x7531;&#x4E8E;&#x5386;&#x53F2;&#x539F;&#x56E0;&#xFF09;
&#xFF0C;&#x7ECF;&#x5E38;&#x5B83;&#x88AB;&#x8FD9;&#x6837;&#x4F7F;&#x7528;&#xFF1A;</p>
<pre><code>dd if=input_file of=output_file [bs=block_size [count=blocks]]
</code></pre><p>Let&#x2019;s say we had two USB flash drives of the same size and we wanted to exactly copy
the first drive to the second. If we attached both drives to the computer and they are
assigned to devices /dev/sdb and /dev/sdc respectively, we could copy everything
on the first drive to the second drive with the following:</p>
<p>&#x6BD4;&#x65B9;&#x8BF4;&#x6211;&#x4EEC;&#x6709;&#x4E24;&#x4E2A;&#x76F8;&#x540C;&#x5BB9;&#x91CF;&#x7684; USB &#x95EA;&#x5B58;&#x9A71;&#x52A8;&#x5668;&#xFF0C;&#x5E76;&#x4E14;&#x8981;&#x7CBE;&#x786E;&#x5730;&#x628A;&#x7B2C;&#x4E00;&#x4E2A;&#x9A71;&#x52A8;&#x5668;&#xFF08;&#x4E2D;&#x7684;&#x5185;&#x5BB9;&#xFF09;
&#x590D;&#x5236;&#x7ED9;&#x7B2C;&#x4E8C;&#x4E2A;&#x3002;&#x5982;&#x679C;&#x8FDE;&#x63A5;&#x4E24;&#x4E2A;&#x8BBE;&#x5907;&#x5230;&#x8BA1;&#x7B97;&#x673A;&#x4E0A;&#xFF0C;&#x5B83;&#x4EEC;&#x5404;&#x81EA;&#x88AB;&#x5206;&#x914D;&#x5230;&#x8BBE;&#x5907;/dev/sdb &#x548C;
/dev/sdc &#x4E0A;&#xFF0C;&#x8FD9;&#x6837;&#x6211;&#x4EEC;&#x5C31;&#x80FD;&#x901A;&#x8FC7;&#x4E0B;&#x9762;&#x7684;&#x547D;&#x4EE4;&#x628A;&#x7B2C;&#x4E00;&#x4E2A;&#x9A71;&#x52A8;&#x5668;&#x4E2D;&#x7684;&#x6240;&#x6709;&#x6570;&#x636E;&#x590D;&#x5236;&#x5230;&#x7B2C;&#x4E8C;&#x4E2A;
&#x9A71;&#x52A8;&#x5668;&#x4E2D;&#x3002;</p>
<pre><code>dd if=/dev/sdb of=/dev/sdc
</code></pre><p>Alternately, if only the first device were attached to the computer, we could copy its
contents to an ordinary file for later restoration or copying:</p>
<p>&#x6216;&#x8005;&#xFF0C;&#x5982;&#x679C;&#x53EA;&#x6709;&#x7B2C;&#x4E00;&#x4E2A;&#x9A71;&#x52A8;&#x5668;&#x88AB;&#x8FDE;&#x63A5;&#x5230;&#x8BA1;&#x7B97;&#x673A;&#x4E0A;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x628A;&#x5B83;&#x7684;&#x5185;&#x5BB9;&#x590D;&#x5236;&#x5230;&#x4E00;&#x4E2A;&#x666E;&#x901A;&#x6587;&#x4EF6;&#x4E2D;&#x4F9B;
&#x4EE5;&#x540E;&#x6062;&#x590D;&#x6216;&#x590D;&#x5236;&#x6570;&#x636E;&#xFF1A;</p>
<pre><code>dd if=/dev/sdb of=flash_drive.img
</code></pre><hr>
<p>Warning! The dd command is very powerful. Though its name derives from &#x201C;data
definition,&#x201D; it is sometimes called &#x201C;destroy disk&#x201D; because users often mistype either
the if or of specifications. <em>Always double check your input and output
specifications before pressing enter!</em></p>
<p>&#x8B66;&#x544A;&#xFF01;&#x8FD9;&#x4E2A; dd &#x547D;&#x4EE4;&#x975E;&#x5E38;&#x5F3A;&#x5927;&#x3002;&#x867D;&#x7136;&#x5B83;&#x7684;&#x540D;&#x5B57;&#x6765;&#x81EA;&#x4E8E;&#x201C;&#x6570;&#x636E;&#x5B9A;&#x4E49;&#x201D;&#xFF0C;&#x6709;&#x65F6;&#x5019;&#x4E5F;&#x628A;&#x5B83;&#x53EB;&#x505A;&#x201C;&#x6E05;&#x9664;&#x78C1;&#x76D8;&#x201D;
&#x56E0;&#x4E3A;&#x7528;&#x6237;&#x7ECF;&#x5E38;&#x4F1A;&#x8BEF;&#x8F93;&#x5165; if &#x6216; of &#x7684;&#x89C4;&#x8303;&#x3002;<em>&#x5728;&#x6309;&#x4E0B;&#x56DE;&#x8F66;&#x952E;&#x4E4B;&#x524D;&#xFF0C;&#x8981;&#x518D;&#x4E09;&#x68C0;&#x67E5;&#x8F93;&#x5165;&#x4E0E;&#x8F93;&#x51FA;&#x89C4;&#x8303;&#xFF01;</em></p>
<hr>
<h3 id="&#x521B;&#x5EFA;-cd-rom-&#x6620;&#x50CF;">&#x521B;&#x5EFA; CD-ROM &#x6620;&#x50CF;</h3>
<p>Writing a recordable CD-ROM (either a CD-R or CD-RW) consists of two steps; first,
constructing an iso image file that is the exact file system image of the CD-ROM and
second, writing the image file onto the CD-ROM media.</p>
<p>&#x5199;&#x5165;&#x4E00;&#x4E2A;&#x53EF;&#x8BB0;&#x5F55;&#x7684; CD-ROM&#xFF08;&#x4E00;&#x4E2A; CD-R &#x6216;&#x8005;&#x662F; CD-RW&#xFF09;&#x7531;&#x4E24;&#x6B65;&#x7EC4;&#x6210;&#xFF1B;&#x9996;&#x5148;&#xFF0C;&#x6784;&#x5EFA;&#x4E00;&#x4E2A; iso &#x6620;&#x50CF;&#x6587;&#x4EF6;&#xFF0C;
&#x8FD9;&#x5C31;&#x662F;&#x4E00;&#x4E2A; CD-ROM &#x7684;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6620;&#x50CF;&#xFF0C;&#x7B2C;&#x4E8C;&#x6B65;&#xFF0C;&#x628A;&#x8FD9;&#x4E2A;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x5199;&#x5165;&#x5230; CD-ROM &#x5A92;&#x4ECB;&#x4E2D;&#x3002;</p>
<h4 id="&#x521B;&#x5EFA;&#x4E00;&#x4E2A;-cd-rom-&#x7684;&#x6620;&#x50CF;&#x62F7;&#x8D1D;">&#x521B;&#x5EFA;&#x4E00;&#x4E2A; CD-ROM &#x7684;&#x6620;&#x50CF;&#x62F7;&#x8D1D;</h4>
<p>If we want to make an iso image of an existing CD-ROM, we can use dd to read all the
data blocks off the CD-ROM and copy them to a local file. Say we had an Ubuntu CD
and we wanted to make an iso file that we could later use to make more copies. After
inserting the CD and determining its device name (we&#x2019;ll assume /dev/cdrom), we can
make the iso file like so:</p>
<p>&#x5982;&#x679C;&#x60F3;&#x8981;&#x5236;&#x4F5C;&#x4E00;&#x5F20;&#x73B0;&#x6709; CD-ROM &#x7684; iso &#x6620;&#x50CF;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4F7F;&#x7528; dd &#x547D;&#x4EE4;&#x6765;&#x8BFB;&#x53D6; CD-ROW &#x4E2D;&#x7684;&#x6240;&#x6709;&#x6570;&#x636E;&#x5757;&#xFF0C;
&#x5E76;&#x628A;&#x5B83;&#x4EEC;&#x590D;&#x5236;&#x5230;&#x672C;&#x5730;&#x6587;&#x4EF6;&#x4E2D;&#x3002;&#x6BD4;&#x5982;&#x8BF4;&#x6211;&#x4EEC;&#x6709;&#x4E00;&#x5F20; Ubuntu
CD&#xFF0C;&#x7528;&#x5B83;&#x6765;&#x5236;&#x4F5C;&#x4E00;&#x4E2A; iso &#x6587;&#x4EF6;&#xFF0C;&#x4EE5;&#x540E;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x7528;&#x5B83;&#x6765;&#x5236;&#x4F5C;&#x66F4;&#x591A;&#x7684;&#x62F7;&#x8D1D;&#x3002;&#x63D2;&#x5165;&#x8FD9;&#x5F20; CD &#x4E4B;&#x540E;&#xFF0C;&#x786E;&#x5B9A;
&#x5B83;&#x7684;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#xFF08;&#x5047;&#x5B9A;&#x662F;/dev/cdrom&#xFF09;&#xFF0C;&#x7136;&#x540E;&#x50CF;&#x8FD9;&#x6837;&#x6765;&#x5236;&#x4F5C; iso &#x6587;&#x4EF6;&#xFF1A;</p>
<pre><code>dd if=/dev/cdrom of=ubuntu.iso
</code></pre><p>This technique works for data DVDs as well, but will not work for audio CDs, as they do
not use a file system for storage. For audio CDs, look at the cdrdao command.</p>
<p>&#x8FD9;&#x9879;&#x6280;&#x672F;&#x4E5F;&#x9002;&#x7528;&#x4E8E; DVD &#x5149;&#x76D8;&#xFF0C;&#x4F46;&#x662F;&#x4E0D;&#x80FD;&#x7528;&#x4E8E;&#x97F3;&#x9891; CD&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x4E0D;&#x4F7F;&#x7528;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6765;&#x5B58;&#x50A8;&#x6570;&#x636E;&#x3002;
&#x5BF9;&#x4E8E;&#x97F3;&#x9891; CD&#xFF0C;&#x770B;&#x4E00;&#x4E0B; cdrdao &#x547D;&#x4EE4;&#x3002;</p>
<h4 id="&#x4ECE;&#x6587;&#x4EF6;&#x96C6;&#x5408;&#x4E2D;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x6620;&#x50CF;">&#x4ECE;&#x6587;&#x4EF6;&#x96C6;&#x5408;&#x4E2D;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x6620;&#x50CF;</h4>
<p>To create an iso image file containing the contents of a directory, we use the
genisoimage program. To do this, we first create a directory containing all the files
we wish to include in the image and then execute the genisoimage command to create
the image file. For example, if we had created a directory called ~/cd-rom-files
and filled it with files for our CD-ROM, we could create an image file named cd-
rom.iso with the following command:</p>
<p>&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x5305;&#x542B;&#x76EE;&#x5F55;&#x5185;&#x5BB9;&#x7684; iso &#x6620;&#x50CF;&#x6587;&#x4EF6;&#xFF0C;&#x6211;&#x4EEC;&#x4F7F;&#x7528; genisoimage &#x7A0B;&#x5E8F;&#x3002;&#x4E3A;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x9996;&#x5148;&#x521B;&#x5EFA;
&#x4E00;&#x4E2A;&#x76EE;&#x5F55;&#xFF0C;&#x8FD9;&#x4E2A;&#x76EE;&#x5F55;&#x4E2D;&#x5305;&#x542B;&#x4E86;&#x8981;&#x5305;&#x62EC;&#x5230;&#x6B64;&#x6620;&#x50CF;&#x4E2D;&#x7684;&#x6240;&#x6709;&#x6587;&#x4EF6;&#xFF0C;&#x7136;&#x540E;&#x6267;&#x884C;&#x8FD9;&#x4E2A; genisoimage &#x547D;&#x4EE4;
&#x6765;&#x521B;&#x5EFA;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x3002;&#x4F8B;&#x5982;&#xFF0C;&#x5982;&#x679C;&#x6211;&#x4EEC;&#x5DF2;&#x7ECF;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x53EB;&#x505A;~/cd-rom-files &#x7684;&#x76EE;&#x5F55;&#xFF0C;&#x7136;&#x540E;&#x7528;&#x6587;&#x4EF6;
&#x586B;&#x5145;&#x6B64;&#x76EE;&#x5F55;&#xFF0C;&#x518D;&#x901A;&#x8FC7;&#x4E0B;&#x9762;&#x7684;&#x547D;&#x4EE4;&#x6765;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x53EB;&#x505A; cd-rom.iso &#x6620;&#x50CF;&#x6587;&#x4EF6;&#xFF1A;</p>
<pre><code>genisoimage -o cd-rom.iso -R -J ~/cd-rom-files
</code></pre><p>The &#x201C;-R&#x201D; option adds metadata for the Rock Ridge extensions, which allows the use of
long filenames and POSIX style file permissions. Likewise, the &#x201C;-J&#x201D; option enables the
Joliet extensions, which permit long filenames for Windows.</p>
<p>&quot;-R&quot;&#x9009;&#x9879;&#x6DFB;&#x52A0;&#x5143;&#x6570;&#x636E;&#x4E3A; Rock Ridge &#x6269;&#x5C55;&#xFF0C;&#x8FD9;&#x5141;&#x8BB8;&#x4F7F;&#x7528;&#x957F;&#x6587;&#x4EF6;&#x540D;&#x548C; POSIX &#x98CE;&#x683C;&#x7684;&#x6587;&#x4EF6;&#x6743;&#x9650;&#x3002;
&#x540C;&#x6837;&#x5730;&#xFF0C;&#x8FD9;&#x4E2A;&quot;-J&quot;&#x9009;&#x9879;&#x4F7F; Joliet &#x6269;&#x5C55;&#x751F;&#x6548;&#xFF0C;&#x8FD9;&#x6837; Windows &#x4E2D;&#x5C31;&#x652F;&#x6301;&#x957F;&#x6587;&#x4EF6;&#x540D;&#x4E86;&#x3002;</p>
<blockquote>
<p>A Program By Any Other Name...</p>
<p>&#x4E00;&#x4E2A;&#x6709;&#x7740;&#x5176;&#x5B83;&#x540D;&#x5B57;&#x7684;&#x7A0B;&#x5E8F;&#x3002;&#x3002;&#x3002;</p>
<p>If you look at on-line tutorials for creating and burning optical media like CD-
ROMs and DVDs, you will frequently encounter two programs called mkisofs
and cdrecord. These programs were part of a popular package called
&#x201C;cdrtools&#x201D; authored by Jorg Schilling. In the summer of 2006, Mr. Schilling
made a license change to a portion of the cdrtools package which, in the opinion
of many in the Linux community, created a license incompatibility with the GNU
GPL. As a result, a fork of the cdrtools project was started that now includes
replacement programs for cdrecord and mkisofs named wodim and
genisoimage, respectively.</p>
<p>&#x5982;&#x679C;&#x4F60;&#x770B;&#x4E00;&#x4E0B;&#x5173;&#x4E8E;&#x521B;&#x5EFA;&#x548C;&#x70E7;&#x5199;&#x5149;&#x4ECB;&#x8D28;&#x5982; CD-ROMs &#x548C; DVD &#x7684;&#x5728;&#x7EBF;&#x6587;&#x6863;&#xFF0C;&#x4F60;&#x4F1A;&#x7ECF;&#x5E38;&#x78B0;&#x5230;&#x4E24;&#x4E2A;&#x7A0B;&#x5E8F;
&#x53EB;&#x505A; mkisofs &#x548C; cdrecord&#x3002;&#x8FD9;&#x4E9B;&#x7A0B;&#x5E8F;&#x662F;&#x6D41;&#x884C;&#x8F6F;&#x4EF6;&#x5305;&quot;cdrtools&quot;&#x7684;&#x4E00;&#x90E8;&#x5206;&#xFF0C;&quot;cdrtools&quot;&#x7531; Jorg Schilling
&#x7F16;&#x5199;&#x6210;&#x3002;&#x5728;2006&#x5E74;&#x6625;&#x5929;&#xFF0C;Schilling &#x5148;&#x751F;&#x66F4;&#x6539;&#x4E86;&#x90E8;&#x5206; cdrtools &#x8F6F;&#x4EF6;&#x5305;&#x7684;&#x534F;&#x8BAE;&#xFF0C;Linux &#x793E;&#x533A;&#x8BB8;&#x591A;&#x4EBA;&#x7684;&#x770B;&#x6CD5;&#x662F;&#xFF0C;
&#x8FD9;&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;&#x4E0E; GNU GPL &#x4E0D;&#x76F8;&#x517C;&#x5BB9;&#x7684;&#x534F;&#x8BAE;&#x3002;&#x7ED3;&#x679C;&#xFF0C;&#x5C31; fork &#x4E86;&#x8FD9;&#x4E2A; cdrtools &#x9879;&#x76EE;&#xFF0C;
&#x76EE;&#x524D;&#x65B0;&#x9879;&#x76EE;&#x91CC;&#x9762;&#x5305;&#x542B;&#x4E86; cdrecord &#x548C; mkisofs &#x7684;&#x66FF;&#x4EE3;&#x7A0B;&#x5E8F;&#xFF0C;&#x5206;&#x522B;&#x662F; wodim &#x548C; genisoimage&#x3002;</p>
</blockquote>
<h3 id="&#x5199;&#x5165;-cd-rom-&#x955C;&#x50CF;">&#x5199;&#x5165; CD-ROM &#x955C;&#x50CF;</h3>
<p>After we have an image file, we can burn it onto our optical media. Most of the
commands we will discuss below can be applied to both recordable CD-ROM and DVD
media.</p>
<p>&#x6709;&#x4E86;&#x4E00;&#x4E2A;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x4E4B;&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x628A;&#x5B83;&#x70E7;&#x5199;&#x5230;&#x5149;&#x76D8;&#x4E2D;&#x3002;&#x4E0B;&#x9762;&#x8BA8;&#x8BBA;&#x7684;&#x5927;&#x591A;&#x6570;&#x547D;&#x4EE4;&#x5BF9;&#x53EF;
&#x8BB0;&#x5F55;&#x7684; CD-ROW &#x548C; DVD &#x5A92;&#x4ECB;&#x90FD;&#x9002;&#x7528;&#x3002;</p>
<h4 id="&#x76F4;&#x63A5;&#x6302;&#x8F7D;&#x4E00;&#x4E2A;-iso-&#x955C;&#x50CF;">&#x76F4;&#x63A5;&#x6302;&#x8F7D;&#x4E00;&#x4E2A; ISO &#x955C;&#x50CF;</h4>
<p>There is a trick that we can use to mount an iso image while it is still on our hard disk and
treat it as though it was already on optical media. By adding the &#x201C;-o loop&#x201D; option to
mount (along with the required &#x201C;-t iso9660&#x201D; file system type), we can mount the image
file as though it were a device and attach it to the file system tree:</p>
<p>&#x6709;&#x4E00;&#x4E2A;&#x8BC0;&#x7A8D;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x7528;&#x5B83;&#x6765;&#x6302;&#x8F7D; iso &#x6620;&#x50CF;&#x6587;&#x4EF6;&#xFF0C;&#x867D;&#x7136;&#x6B64;&#x6587;&#x4EF6;&#x4ECD;&#x7136;&#x5728;&#x6211;&#x4EEC;&#x7684;&#x786C;&#x76D8;&#x4E2D;&#xFF0C;&#x4F46;&#x6211;&#x4EEC;
&#x5F53;&#x4F5C;&#x5B83;&#x5DF2;&#x7ECF;&#x5728;&#x5149;&#x76D8;&#x4E2D;&#x4E86;&#x3002;&#x6DFB;&#x52A0; &quot;-o loop&quot; &#x9009;&#x9879;&#x6765;&#x6302;&#x8F7D;&#xFF08;&#x540C;&#x65F6;&#x5E26;&#x6709;&#x5FC5;&#x9700;&#x7684; &quot;-t iso9660&quot; &#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x7C7B;&#x578B;&#xFF09;&#xFF0C;
&#x6302;&#x8F7D;&#x8FD9;&#x4E2A;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x5C31;&#x597D;&#x50CF;&#x5B83;&#x662F;&#x4E00;&#x53F0;&#x8BBE;&#x5907;&#xFF0C;&#x628A;&#x5B83;&#x8FDE;&#x63A5;&#x5230;&#x6587;&#x4EF6;&#x7CFB;&#x7EDF;&#x6811;&#x4E0A;&#xFF1A;</p>
<pre><code>mkdir /mnt/iso_image
mount -t iso9660 -o loop image.iso /mnt/iso_image
</code></pre><p>In the example above, we created a mount point named /mnt/iso_image and then
mounted the image file image.iso at that mount point. After the image is mounted, it
can be treated just as though it were a real CD-ROM or DVD. Remember to unmount the
image when it is no longer needed.</p>
<p>&#x4E0A;&#x9762;&#x7684;&#x793A;&#x4F8B;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;&#x6302;&#x8F7D;&#x70B9;&#x53EB;&#x505A;/mnt/iso_image&#xFF0C;&#x7136;&#x540E;&#x628A;&#x6B64;&#x6620;&#x50CF;&#x6587;&#x4EF6;
image.iso &#x6302;&#x8F7D;&#x5230;&#x6302;&#x8F7D;&#x70B9;&#x4E0A;&#x3002;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x88AB;&#x6302;&#x8F7D;&#x4E4B;&#x540E;&#xFF0C;&#x53EF;&#x4EE5;&#x628A;&#x5B83;&#x5F53;&#x4F5C;&#xFF0C;&#x5C31;&#x597D;&#x50CF;&#x5B83;&#x662F;&#x4E00;&#x5F20;
&#x771F;&#x6B63;&#x7684; CD-ROM &#x6216;&#x8005; DVD&#x3002;&#x5F53;&#x4E0D;&#x518D;&#x9700;&#x8981;&#x6B64;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x540E;&#xFF0C;&#x8BB0;&#x5F97;&#x5378;&#x8F7D;&#x5B83;&#x3002;</p>
<h4 id="&#x6E05;&#x9664;&#x4E00;&#x5F20;&#x53EF;&#x91CD;&#x5199;&#x5165;&#x7684;-cd-rom">&#x6E05;&#x9664;&#x4E00;&#x5F20;&#x53EF;&#x91CD;&#x5199;&#x5165;&#x7684; CD-ROM</h4>
<p>Rewritable CD-RW media needs to be erased or blanked before it can be reused. To do
this, we can use wodim, specifying the device name for the CD writer and the type of
blanking to be performed. The wodim program offers several types. The most minimal
(and fastest) is the &#x201C;fast&#x201D; type:</p>
<p>&#x53EF;&#x91CD;&#x5199;&#x5165;&#x7684; CD-RW &#x5A92;&#x4ECB;&#x5728;&#x88AB;&#x91CD;&#x4F7F;&#x7528;&#x4E4B;&#x524D;&#x9700;&#x8981;&#x64E6;&#x9664;&#x6216;&#x6E05;&#x7A7A;&#x3002;&#x4E3A;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x7528; wodim &#x547D;&#x4EE4;&#xFF0C;&#x6307;&#x5B9A;
&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x548C;&#x6E05;&#x7A7A;&#x7684;&#x7C7B;&#x578B;&#x3002;&#x6B64; wodim &#x7A0B;&#x5E8F;&#x63D0;&#x4F9B;&#x4E86;&#x51E0;&#x79CD;&#x6E05;&#x7A7A;&#x7C7B;&#x578B;&#x3002;&#x6700;&#x5C0F;&#xFF08;&#x4E14;&#x6700;&#x5FEB;&#xFF09;&#x7684;&#x662F; &quot;fast&quot; &#x7C7B;&#x578B;&#xFF1A;</p>
<pre><code>wodim dev=/dev/cdrw blank=fast
</code></pre><h4 id="&#x5199;&#x5165;&#x955C;&#x50CF;">&#x5199;&#x5165;&#x955C;&#x50CF;</h4>
<p>To write an image, we again use wodim, specifying the name of the optical media writer
device and the name of the image file:</p>
<p>&#x5199;&#x5165;&#x4E00;&#x4E2A;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#xFF0C;&#x6211;&#x4EEC;&#x518D;&#x6B21;&#x4F7F;&#x7528; wodim &#x547D;&#x4EE4;&#xFF0C;&#x6307;&#x5B9A;&#x5149;&#x76D8;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x548C;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x540D;&#xFF1A;</p>
<pre><code>wodim dev=/dev/cdrw image.iso
</code></pre><p>In addition to the device name and image file, wodim supports a very large set of
options. Two common ones are &#x201C;-v&#x201D; for verbose output, and &#x201C;-dao&#x201D; which writes the disk
in disk-at-once mode. This mode should be used if you are preparing a disk for
commercial reproduction. The default mode for wodim is track-at-once, which is useful
for recording music tracks.</p>
<p>&#x9664;&#x4E86;&#x8BBE;&#x5907;&#x540D;&#x79F0;&#x548C;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x4E4B;&#x5916;&#xFF0C;wodim &#x547D;&#x4EE4;&#x8FD8;&#x652F;&#x6301;&#x975E;&#x5E38;&#x591A;&#x7684;&#x9009;&#x9879;&#x3002;&#x5E38;&#x89C1;&#x7684;&#x4E24;&#x4E2A;&#x9009;&#x9879;&#x662F;&#xFF0C;&quot;-v&quot; &#x53EF;&#x8BE6;&#x7EC6;&#x8F93;&#x51FA;&#xFF0C;
&#x548C; &quot;&#xFF0D;dao&quot; &#x4EE5; disk-at-once &#x6A21;&#x5F0F;&#x5199;&#x5165;&#x5149;&#x76D8;&#x3002;&#x5982;&#x679C;&#x4F60;&#x6B63;&#x5728;&#x51C6;&#x5907;&#x4E00;&#x5F20;&#x5149;&#x76D8;&#x4E3A;&#x7684;&#x662F;&#x5546;&#x4E1A;&#x590D;&#x5236;&#xFF0C;&#x90A3;&#x4E48;&#x5E94;&#x8BE5;&#x4F7F;&#x7528;&#x8FD9;&#x79CD;&#x6A21;&#x5F0F;&#x3002;
wodim &#x547D;&#x4EE4;&#x7684;&#x9ED8;&#x8BA4;&#x6A21;&#x5F0F;&#x662F; track-at-once&#xFF0C;&#x8FD9;&#x5BF9;&#x4E8E;&#x5F55;&#x5236;&#x97F3;&#x4E50;&#x5F88;&#x6709;&#x7528;&#x3002;</p>
<h3 id="&#x62D3;&#x5C55;&#x9605;&#x8BFB;">&#x62D3;&#x5C55;&#x9605;&#x8BFB;</h3>
<p>We have just touched on the many ways that the command line can be used to manage
storage media. Take a look at the man pages of the commands we have covered. Some
of them support huge numbers of options and operations. Also, look for on-line tutorials
for adding hard drives to your Linux system (there are many) and working with optical
media.</p>
<p>&#x6211;&#x4EEC;&#x521A;&#x624D;&#x8C08;&#x5230;&#x4E86;&#x5F88;&#x591A;&#x65B9;&#x6CD5;&#xFF0C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x547D;&#x4EE4;&#x884C;&#x7BA1;&#x7406;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#x3002;&#x770B;&#x770B;&#x6211;&#x4EEC;&#x6240;&#x8BB2;&#x8FC7;&#x547D;&#x4EE4;&#x7684;&#x624B;&#x518C;&#x9875;&#x3002;
&#x4E00;&#x4E9B;&#x547D;&#x4EE4;&#x652F;&#x6301;&#x5927;&#x91CF;&#x7684;&#x9009;&#x9879;&#x548C;&#x64CD;&#x4F5C;&#x3002;&#x6B64;&#x5916;&#xFF0C;&#x5BFB;&#x627E;&#x4E00;&#x4E9B;&#x5982;&#x4F55;&#x6DFB;&#x52A0;&#x786C;&#x76D8;&#x9A71;&#x52A8;&#x5668;&#x5230; Linux &#x7CFB;&#x7EDF;&#xFF08;&#x6709;&#x8BB8;&#x591A;&#xFF09;&#x7684;&#x5728;&#x7EBF;&#x6559;&#x7A0B;&#xFF0C;
&#x8FD9;&#x4E9B;&#x6559;&#x7A0B;&#x4E5F;&#x8981;&#x9002;&#x7528;&#x4E8E;&#x5149;&#x4ECB;&#x8D28;&#x5B58;&#x50A8;&#x8BBE;&#x5907;&#x3002;</p>
<h3 id="&#x53CB;&#x60C5;&#x63D0;&#x793A;">&#x53CB;&#x60C5;&#x63D0;&#x793A;</h3>
<p>It&#x2019;s often useful to verify the integrity of an iso image that we have downloaded. In most
cases, a distributor of an iso image will also supply a checksum file. A checksum is the
result of an exotic mathematical calculation resulting in a number that represents the
content of the target file. If the contents of the file change by even one bit, the resulting
checksum will be much different. The most common method of checksum generation
uses the md5sum program. When you use md5sum, it produces a unique hexadecimal
number:</p>
<p>&#x901A;&#x5E38;&#x9A8C;&#x8BC1;&#x4E00;&#x4E0B;&#x6211;&#x4EEC;&#x5DF2;&#x7ECF;&#x4E0B;&#x8F7D;&#x7684; iso &#x6620;&#x50CF;&#x6587;&#x4EF6;&#x7684;&#x5B8C;&#x6574;&#x6027;&#x5F88;&#x6709;&#x7528;&#x5904;&#x3002;&#x5728;&#x5927;&#x591A;&#x6570;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;iso &#x6620;&#x50CF;&#x6587;&#x4EF6;&#x7684;&#x8D21;&#x732E;&#x8005;&#x4E5F;&#x4F1A;&#x63D0;&#x4F9B;
&#x4E00;&#x4E2A; checksum &#x6587;&#x4EF6;&#x3002;&#x4E00;&#x4E2A; checksum &#x662F;&#x4E00;&#x4E2A;&#x795E;&#x5947;&#x7684;&#x6570;&#x5B66;&#x8FD0;&#x7B97;&#x7684;&#x8BA1;&#x7B97;&#x7ED3;&#x679C;&#xFF0C;&#x8FD9;&#x4E2A;&#x6570;&#x5B66;&#x8BA1;&#x7B97;&#x4F1A;&#x4EA7;&#x751F;&#x4E00;&#x4E2A;&#x80FD;&#x8868;&#x793A;&#x76EE;&#x6807;&#x6587;&#x4EF6;&#x5185;&#x5BB9;&#x7684;&#x6570;&#x5B57;&#x3002;
&#x5982;&#x679C;&#x76EE;&#x6807;&#x6587;&#x4EF6;&#x7684;&#x5185;&#x5BB9;&#x5373;&#x4F7F;&#x66F4;&#x6539;&#x4E00;&#x4E2A;&#x4E8C;&#x8FDB;&#x5236;&#x4F4D;&#xFF0C;checksum &#x7684;&#x7ED3;&#x679C;&#x5C06;&#x4F1A;&#x975E;&#x5E38;&#x4E0D;&#x4E00;&#x6837;&#x3002;
&#x751F;&#x6210; checksum &#x6570;&#x5B57;&#x7684;&#x6700;&#x5E38;&#x89C1;&#x65B9;&#x6CD5;&#x662F;&#x4F7F;&#x7528; md5sum &#x7A0B;&#x5E8F;&#x3002;&#x5F53;&#x4F60;&#x4F7F;&#x7528; md5sum &#x7A0B;&#x5E8F;&#x7684;&#x65F6;&#x5019;&#xFF0C;
&#x5B83;&#x4F1A;&#x4EA7;&#x751F;&#x4E00;&#x4E2A;&#x72EC;&#x4E00;&#x65E0;&#x4E8C;&#x7684;&#x5341;&#x516D;&#x8FDB;&#x5236;&#x6570;&#x5B57;&#xFF1A;</p>
<pre><code>md5sum image.iso
34e354760f9bb7fbf85c96f6a3f94ece    image.iso
</code></pre><p>After you download an image, you should run md5sum against it and compare the results
with the md5sum value supplied by the publisher.</p>
<p>&#x5F53;&#x4F60;&#x4E0B;&#x8F7D;&#x5B8C;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x4E4B;&#x540E;&#xFF0C;&#x4F60;&#x5E94;&#x8BE5;&#x5BF9;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x6267;&#x884C; md5sum &#x547D;&#x4EE4;&#xFF0C;&#x7136;&#x540E;&#x628A;&#x8FD0;&#x884C;&#x7ED3;&#x679C;&#x4E0E;&#x53D1;&#x884C;&#x5546;&#x63D0;&#x4F9B;&#x7684; md5sum &#x6570;&#x503C;&#x4F5C;&#x6BD4;&#x8F83;&#x3002;</p>
<p>In addition to checking the integrity of a downloaded file, we can use md5sum to verify
newly written optical media. To do this, we first calculate the checksum of the image file
and then calculate a checksum for the media. The trick to verifying the media is to limit
the calculation to only the portion of the optical media that contains the image. We do
this by determining the number of 2048 byte blocks the image contains (optical media is
always written in 2048 byte blocks) and reading that many blocks from the media. On
some types of media, this is not required. A CD-R written in disk-at-once mode can be
checked this way:</p>
<p>&#x9664;&#x4E86;&#x68C0;&#x67E5;&#x4E0B;&#x8F7D;&#x6587;&#x4EF6;&#x7684;&#x5B8C;&#x6574;&#x6027;&#x4E4B;&#x5916;&#xFF0C;&#x6211;&#x4EEC;&#x4E5F;&#x53EF;&#x4EE5;&#x4F7F;&#x7528; md5sum &#x7A0B;&#x5E8F;&#x9A8C;&#x8BC1;&#x65B0;&#x5199;&#x5165;&#x7684;&#x5149;&#x5B66;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#x3002;
&#x4E3A;&#x6B64;&#xFF0C;&#x9996;&#x5148;&#x6211;&#x4EEC;&#x8BA1;&#x7B97;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x7684; checksum &#x6570;&#x503C;&#xFF0C;&#x7136;&#x540E;&#x8BA1;&#x7B97;&#x6B64;&#x5149;&#x5B66;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#x7684; checksum &#x6570;&#x503C;&#x3002;
&#x8FD9;&#x79CD;&#x9A8C;&#x8BC1;&#x5149;&#x5B66;&#x4ECB;&#x8D28;&#x7684;&#x6280;&#x5DE7;&#x662F;&#x9650;&#x5B9A;&#x53EA;&#x5BF9; &#x5149;&#x5B66;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#x4E2D;&#x5305;&#x542B;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x7684;&#x90E8;&#x5206;&#x8BA1;&#x7B97; checksum &#x6570;&#x503C;&#x3002;
&#x901A;&#x8FC7;&#x786E;&#x5B9A;&#x6620;&#x50CF;&#x6587;&#x4EF6;&#x6240;&#x5305;&#x542B;&#x7684; 2048 &#x4E2A;&#x5B57;&#x8282;&#x5757;&#x7684;&#x6570;&#x76EE;&#xFF08;&#x5149;&#x5B66;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#x603B;&#x662F;&#x4EE5; 2048 &#x4E2A;&#x5B57;&#x8282;&#x5757;&#x7684;&#x65B9;&#x5F0F;&#x5199;&#x5165;&#xFF09;
&#x5E76;&#x4ECE;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#x4E2D;&#x8BFB;&#x53D6;&#x90A3;&#x4E48;&#x591A;&#x7684;&#x5B57;&#x8282;&#x5757;&#xFF0C;&#x6211;&#x4EEC;&#x5C31;&#x53EF;&#x4EE5;&#x5B8C;&#x6210;&#x64CD;&#x4F5C;&#x3002;
&#x67D0;&#x4E9B;&#x7C7B;&#x578B;&#x7684;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#xFF0C;&#x5E76;&#x4E0D;&#x9700;&#x8981;&#x8FD9;&#x6837;&#x505A;&#x3002;&#x4E00;&#x4E2A;&#x4EE5; disk-at-once &#x6A21;&#x5F0F;&#x5199;&#x5165;&#x7684; CD-R&#xFF0C;&#x53EF;&#x4EE5;&#x7528;&#x4E0B;&#x9762;&#x7684;&#x65B9;&#x5F0F;&#x68C0;&#x9A8C;&#xFF1A;</p>
<pre><code>md5sum /dev/cdrom
34e354760f9bb7fbf85c96f6a3f94ece    /dev/cdrom
</code></pre><p>Many types of media, such as DVDs require a precise calculation of the number of
blocks. In the example below, we check the integrity of the image file dvd-image.iso
and the disk in the DVD reader /dev/dvd. Can you figure out how this works?</p>
<p>&#x8BB8;&#x591A;&#x5B58;&#x50A8;&#x4ECB;&#x8D28;&#x7C7B;&#x578B;&#xFF0C;&#x5982; DVD &#x9700;&#x8981;&#x7CBE;&#x786E;&#x5730;&#x8BA1;&#x7B97;&#x5B57;&#x8282;&#x5757;&#x7684;&#x6570;&#x76EE;&#x3002;&#x5728;&#x4E0B;&#x9762;&#x7684;&#x4F8B;&#x5B50;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x68C0;&#x9A8C;&#x4E86;&#x6620;&#x50CF;&#x6587;&#x4EF6; dvd-image.iso
&#x4EE5;&#x53CA; DVD &#x5149;&#x9A71;&#x4E2D;&#x78C1;&#x76D8; /dev/dvd &#x6587;&#x4EF6;&#x7684;&#x5B8C;&#x6574;&#x6027;&#x3002;&#x4F60;&#x80FD;&#x5F04;&#x660E;&#x767D;&#x8FD9;&#x662F;&#x600E;&#x4E48;&#x56DE;&#x4E8B;&#x5417;&#xFF1F;</p>
<pre><code>md5sum dvd-image.iso; dd if=/dev/dvd bs=2048 count=$(( $(stat -c &quot;%s&quot; dvd-image.iso) / 2048 )) | md5sum
</code></pre>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="chap15.html" class="navigation navigation-prev " aria-label="Previous page: 15. 软件包管理">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="chap17.html" class="navigation navigation-next " aria-label="Next page: 17. 网络系统">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"layout":"book","title":"16. 存储媒介","level":"1.1.16","depth":2,"next":{"title":"17. 网络系统","level":"1.1.17","depth":2,"path":"chap17.md","ref":"chap17.md","articles":[]},"previous":{"title":"15. 软件包管理","level":"1.1.15","depth":2,"path":"chap15.md","ref":"chap15.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"en","gitbook":"*"},"file":{"path":"chap16.md","mtime":"2017-01-12T13:21:32.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-01-12T13:23:32.099Z"},"basePath":".","book":{"language":"en"}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

